/////////////////////////////////////////////////////////////////////////////
// Project ePamms
//
// This is a part of the ePamms applications package.
// Copyright (c) 2007 - 2017 Arksoft, Inc.
// All Rights Reserved.
//
// SUBSYSTEM:    mSPLDef       - Primary Registrant Label Content operations
// FILE:         mSPLDef.vml
// AUTHOR:       Doug Sorensen
//
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//
//  OPERATION: GeneratePDF_Label
//
/////////////////////////////////////////////////////////////////////////////
TRANSFORMATION OPERATION
GeneratePDF_Label( VIEW mSPLDef BASED ON LOD mSPLDef )

   VIEW wWebXfer REGISTERED AS wWebXfer
   VIEW mSPLDefPDF BASED ON LOD mSPLDef
   VIEW mSPLDefContinue BASED ON LOD mSPLDef
   STRING ( 32000 ) szWriteBuffer
   INTEGER lFile
   INTEGER lControl
   STRING ( 50 ) szLeadingBlanks
   STRING ( 32 ) szSize
   STRING ( 32 ) szTop
   STRING ( 32 ) szHeight
   STRING ( 32 ) szWidth
   STRING ( 32 ) szPageHeight
   STRING ( 32 ) szPageWidth
   STRING ( 32 ) szLeft
   STRING ( 32 ) szLastSectionType
   STRING ( 32 ) szVoid
   STRING ( 2 )  szCount
   STRING ( 40 ) szPanelDottedBorder
   STRING ( 2 )  szSequenceNumber
   STRING ( 50 ) szSectionName
   INTEGER       lCount
   SHORT         nRC
   DECIMAL       InterPanelSpace
   DECIMAL       Left
   DECIMAL       Temp
   STRING ( 32 ) szLPLR_Name
   STRING ( 64 ) szSystemIniApplName
   STRING ( 64 ) szLabelName
   STRING ( 256 ) szDirectory
   STRING ( 256 ) szApplication
   STRING ( 256 ) szXmlName
   STRING ( 256 ) szXslName
   STRING ( 30 ) szDateTime
   STRING ( 30 ) szDateTimeDisplay

   // Generate a PDF Label from the SPLD.
   SysGetDateTime( szDateTime )
   mSPLDef.SubregPhysicalLabelDef.wDateTime = szDateTime

   // Delete any existing DisplaySection entries.
   FOR EACH mSPLDef.DisplaySection
      DELETE ENTITY mSPLDef.DisplaySection NONE
   END

   // Open the File
// SfGetApplicationForSubtask( szLPLR_Name, mSPLDef )
// szSystemIniApplName = "[App." + szLPLR_Name + "]"
// SysReadZeidonIni( -1, szSystemIniApplName, "WebDirectory", szDirectory )
// SysConvertEnvironmentString( szDirectory, szDirectory )
// szDirectory = "C:/Program Files/Apache Group/tomcat 7.0/webapps/ROOT/epamms/"

   SysGetEnvVar( szDirectory, "CATALINA_HOME", 256 )
// SysAppendcDirSep( szDirectory )
   SysConvertEnvironmentString( szDirectory, szDirectory )
   szDirectory = szDirectory + "/webapps/ROOT/"
   szApplication = mSPLDef.SubregOrganization.LoginName
   RemoveInvalidCharsFromFilename( szApplication )

   szLabelName = mSPLDef.SubregProduct.Name + "." + mSPLDef.SubregLabelContent.Version + "." + mSPLDef.SubregPhysicalLabelDef.Name + "." + wWebXfer.Root.LoginName
   RemoveInvalidCharsFromFilename( szLabelName )

   szXmlName = szDirectory + szApplication + "/xml/"
   szXslName = szDirectory + szApplication + "/xsl/"
   SysValidDirOrFile( szXmlName, 1, 1, 256 )
   SysValidDirOrFile( szXslName, 1, 1, 256 )
   szXmlName = szXmlName + szLabelName + ".xml"
   szXslName = szXslName + szLabelName + ".xsl"
   TraceLineS( "mSPLDef Output Xml Filename: ", szXmlName )
   TraceLineS( "mSPLDef Output Xsl Filename: ", szXslName )
   lFile = SysOpenFile( mSPLDef, szXslName, COREFILE_WRITE )
   IF lFile < 0
      MessageSend( mSPLDef, "", "Generate Label",
                   "Error opening output file.",
                   zMSGQ_OBJECT_CONSTRAINT_ERROR, 0 )
      RETURN 2
   END
// TraceLineS( "##### After open: ", szXslName )

   // Put out XSL header data.
   szWriteBuffer = "<?xml version=@1.0@ encoding='iso-8859-1'?>"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "@", 0 )

   GetStringFromAttributeByContext( szDateTimeDisplay, mSPLDef, "SubregPhysicalLabelDef", "wDateTime", "YYYY/MM/DD HH:MM:SS.S AM", 30 )
   szWriteBuffer = "<!-- Output created by ePamms   " + szDateTimeDisplay + " -->"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

   szWriteBuffer = "<xsl:stylesheet version=^1.0^"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )
   szWriteBuffer = "   xmlns:xsl=^http://www.w3.org/1999/XSL/Transform^"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )
   szWriteBuffer = "   xmlns:fo=^http://www.w3.org/1999/XSL/Format^"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )
   szWriteBuffer = "   xmlns:fox=^http://xml.apache.org/fop/extensions^"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )
   szWriteBuffer = "   xmlns:exslt=^http://exslt.org/common^"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )
   szWriteBuffer = "   xmlns:exsl=^http://exslt.org/common^"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )
   szWriteBuffer = "   extension-element-prefixes=^exsl^"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )
   szWriteBuffer = "   xmlns:msxsl=^urn:schemas-microsoft-com:xslt^"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )
   szWriteBuffer = "   exclude-result-prefixes=^msxsl^>"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )
   szWriteBuffer = ""
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )
   szWriteBuffer = "   <xsl:output method=^xml^ indent=^yes^/>"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

   // Beginning of XSL Label Definition
   szWriteBuffer = "   <xsl:template match=^/zOI^>"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )
   szWriteBuffer = "      <fo:root>"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )
   szWriteBuffer = "         <fo:layout-master-set>"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

   // Page
   Temp = mSPLDef.LLD_Page.Height + 2.0  // add 1-inch border
   szPageHeight = Temp
   Temp = mSPLDef.LLD_Page.Width + 2.0 // add 1-inch border
   szPageWidth  = Temp
   szWriteBuffer = "            <fo:simple-page-master master-name=^p1^ page-width=^" + szPageWidth + "in^ page-height=^" + szPageHeight + "in^>"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

   szWriteBuffer = "               <fo:region-body region-name=^xsl-region-body^ margin=^0.2in^/>"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )
   szWriteBuffer = "            </fo:simple-page-master>"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )
   szWriteBuffer = "         </fo:layout-master-set>"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )
   szWriteBuffer = "         <fo:page-sequence master-reference=^p1^>"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )
   szWriteBuffer = "            <fo:flow flow-name=^xsl-region-body^>"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

   // Generate unique XML name for each Marketing Section, which contains a sequence number suffix.
   lCount = 0
   FOR EACH mSPLDef.SPLD_MarketingSection
      lCount = lCount + 1
      szSequenceNumber = lCount
      szSectionName = "SPLD_MarketingSection" + szSequenceNumber
      mSPLDef.SPLD_MarketingSection.wXML_MarketingName = szSectionName
   END
   mSPLDef.SubregPhysicalLabelDef.wLastDisplaySuffixCount = 0

   // Generate printer location icons.
   FormatPrintIcons( mSPLDef, lFile, szWriteBuffer )

   // Compute the Top Position values for each Block and SubBlock.
   ComputeTopPositions( mSPLDef )

   // Reset the wContinuedFromTag for each Block and SubBlock.
// TraverseBlocks( mSPLDef )  May use when we include "continuation" blocks

   // Loop through each PANEL, creating a Panel with Block containers.
   lCount          = 0
   Left            = 1.0
   InterPanelSpace = 0.75
   IF mSPLDef.SubregPhysicalLabelDef.wFormatWithDottedBorders = "Y"
   // TraceLineS( "Generate PDF Label with borders", "" )
      szPanelDottedBorder = " border=^1.0pt dotted green^"
   ELSE
   // TraceLineS( "Generate PDF Label without borders", "" )
      szPanelDottedBorder = ""
   END
   FOR EACH mSPLDef.LLD_Panel

      lCount = lCount + 1
      szCount = lCount
      szLeft = Left

      // Panel Container
      //szTop        = "1.0"
      Temp = mSPLDef.LLD_Panel.Top + 1.0
      szTop = Temp
      Temp = mSPLDef.LLD_Panel.Left + 1.0
      szLeft = Temp
      szHeight     = mSPLDef.LLD_Panel.Height
      szWidth      = mSPLDef.LLD_Panel.Width
      szWriteBuffer = "               <fo:block-container position=^absolute^ top=^" + szTop + "in^ left=^" + szLeft +
                      "in^ height=^" + szHeight + "in^ width=^" + szWidth + "in^" + szPanelDottedBorder + ">"
      WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )
      szWriteBuffer = ""
      WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

      // Panel Number
      szWriteBuffer = "                  <!-- Panel Number " + szCount
      WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )
      szWriteBuffer = "                  <fo:block-container position=^absolute^ top=^-0.2in^ left=^-0.2in^>"
      WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )
      szWriteBuffer = "                     <fo:block text-align=^left^>"
      WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )
      szWriteBuffer = "                        " + szCount
      WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )
      szWriteBuffer = "                     </fo:block>"
      WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )
      szWriteBuffer = "                  </fo:block-container>"
      WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )
      szWriteBuffer = "                  -->"
      WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )
      szWriteBuffer = ""
      WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

      IF mSPLDef.LLD_Block EXISTS
      
         // Process each Block within the Panel.
         CreateViewFromView( mSPLDefPDF, mSPLDef )
         CreateViewFromView( mSPLDefContinue, mSPLDef )
         NAME VIEW mSPLDefPDF "mSPLDefPDF"
         //NAME VIEW mSPLDefContinue "mSPLDefContinue"
         //NAME VIEW mSPLDef "mSPLDef"

         // Top call to ProcessPDF_Blocks <<=====================
         szLeadingBlanks = "               "
         nRC = ProcessPDF_Blocks( mSPLDef, mSPLDefPDF, mSPLDefContinue, lFile, szLeadingBlanks, szWriteBuffer )
         DropView( mSPLDefContinue )
         DropView( mSPLDefPDF )
         IF nRC = 2
            RETURN 2
         END
      ELSE
         WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )
         szWriteBuffer = "                  <fo:block-container position=^absolute^ top=^-0.2in^ left=^-0.2in^>"
         WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )
         szWriteBuffer = "                     <fo:block text-align=^left^>"
         WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )
         szWriteBuffer = "      Empty Panel"
         WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )
         szWriteBuffer = "                     </fo:block>"
         WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )
         szWriteBuffer = "                  </fo:block-container>"
         WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )
         szWriteBuffer = ""
         WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )
      END

      // Close Panel Container.
      szWriteBuffer = "               </fo:block-container>"
      WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

      // Increment Left position for next Panel.
      Left = Left + InterPanelSpace + mSPLDef.LLD_Panel.Width

   END

   // Close XSL body.
   szWriteBuffer = "            </fo:flow>"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )
   szWriteBuffer = "         </fo:page-sequence>"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )
   szWriteBuffer = "      </fo:root>"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )
   szWriteBuffer = "   </xsl:template>"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )
   szWriteBuffer = ""
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

   // Sub Template.
   szWriteBuffer = "   <xsl:template match=^sub^>"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )
   szWriteBuffer = "      <fo:inline vertical-align=^sub^ font-size=^75%^>"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )
   szWriteBuffer = "         <xsl:apply-templates select=^*||text()^/>"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )
   szWriteBuffer = "      </fo:inline>"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )
   szWriteBuffer = "   </xsl:template>"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

   // Bold Template.
   szWriteBuffer = "   <xsl:template match=^bold^>"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )
   szWriteBuffer = "      <fo:inline font-weight=^bold^>"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )
   szWriteBuffer = "         <xsl:apply-templates select=^*||text()^/>"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )
   szWriteBuffer = "      </fo:inline>"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )
   szWriteBuffer = "   </xsl:template>"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

   // Conclude XSL.
   szWriteBuffer = ""
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )
   szWriteBuffer = "</xsl:stylesheet>"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )


   // Close the XSL file.
   SysCloseFile( mSPLDef, lFile, 0 )

   // Generate XML. We do this at the end because the process above built data (e.g.  wkDisplayText attributes) in the mSPLDef object instance.
// szWriteBuffer = "c:\lplr\epamms\xsl\TestLabel.xml"
// CommitOI_ToXML_File( mSPLDef, szWriteBuffer, 0 )
   TraceLineS( "Output Xml Directory/File Name: ", szXmlName )
   GenerateXML_File( mSPLDef, "SubregPhysicalLabelDef", szXmlName )

END

LOCAL OPERATION
AddBlockAttribute( VIEW mSPLDefBlock BASED ON LOD mSPLDef, STRING (33) strAttribute, STRING (4096) szDisplayMsg )
   STRING ( 256 ) szAttributeValue

   GetStringFromAttribute( szAttributeValue, mSPLDefBlock, "LLD_Block", strAttribute )
// TraceLineS( "AddBlockAttribute: ", szAttributeValue )
   IF szAttributeValue != ""
      szDisplayMsg = szDisplayMsg + "  " + strAttribute + ": " + szAttributeValue
   END
END

LOCAL OPERATION
DisplayBlockAttributes( VIEW mSPLDefBlock BASED ON LOD mSPLDef, INTEGER bAll )

   STRING ( 4096 ) szDisplayMsg
   INTEGER lMinLth
   INTEGER lLth

   szDisplayMsg = " --- Block"
   AddBlockAttribute( mSPLDefBlock, "ID", szDisplayMsg )
   AddBlockAttribute( mSPLDefBlock, "Top", szDisplayMsg )
   AddBlockAttribute( mSPLDefBlock, "Left", szDisplayMsg )
   AddBlockAttribute( mSPLDefBlock, "Height", szDisplayMsg )
   AddBlockAttribute( mSPLDefBlock, "Width", szDisplayMsg )

   lMinLth = zstrlen( szDisplayMsg )

   AddBlockAttribute( mSPLDefBlock, "Tag", szDisplayMsg )
   AddBlockAttribute( mSPLDefBlock, "Name", szDisplayMsg )
   AddBlockAttribute( mSPLDefBlock, "BlockTitle", szDisplayMsg )
   AddBlockAttribute( mSPLDefBlock, "LLD_SectionType", szDisplayMsg )
   AddBlockAttribute( mSPLDefBlock, "LLD_ColumnListType", szDisplayMsg )
   AddBlockAttribute( mSPLDefBlock, "ContinuationBlockFlag", szDisplayMsg )
   AddBlockAttribute( mSPLDefBlock, "ImageName", szDisplayMsg )
   AddBlockAttribute( mSPLDefBlock, "TextColor", szDisplayMsg )
   AddBlockAttribute( mSPLDefBlock, "TextColorOverride", szDisplayMsg )
   AddBlockAttribute( mSPLDefBlock, "BackgroundColor", szDisplayMsg )
   AddBlockAttribute( mSPLDefBlock, "BackgroundColorOverride", szDisplayMsg )
   AddBlockAttribute( mSPLDefBlock, "BorderColor", szDisplayMsg )
   AddBlockAttribute( mSPLDefBlock, "BorderColorOverride", szDisplayMsg )
   AddBlockAttribute( mSPLDefBlock, "BorderStyle", szDisplayMsg )
   AddBlockAttribute( mSPLDefBlock, "BorderWidth", szDisplayMsg )
   AddBlockAttribute( mSPLDefBlock, "FontFamily", szDisplayMsg )
   AddBlockAttribute( mSPLDefBlock, "FontSize", szDisplayMsg )
   AddBlockAttribute( mSPLDefBlock, "FontWeight", szDisplayMsg )
   AddBlockAttribute( mSPLDefBlock, "Margin", szDisplayMsg )
   AddBlockAttribute( mSPLDefBlock, "MarginTop", szDisplayMsg )
   AddBlockAttribute( mSPLDefBlock, "MarginLeft", szDisplayMsg )
   AddBlockAttribute( mSPLDefBlock, "MarginBottom", szDisplayMsg )
   AddBlockAttribute( mSPLDefBlock, "MarginRight", szDisplayMsg )
   AddBlockAttribute( mSPLDefBlock, "MarginOverride", szDisplayMsg )
   AddBlockAttribute( mSPLDefBlock, "Border", szDisplayMsg )
   AddBlockAttribute( mSPLDefBlock, "BorderTop", szDisplayMsg )
   AddBlockAttribute( mSPLDefBlock, "BorderBottom", szDisplayMsg )
   AddBlockAttribute( mSPLDefBlock, "BorderLeft", szDisplayMsg )
   AddBlockAttribute( mSPLDefBlock, "BorderRight", szDisplayMsg )
   AddBlockAttribute( mSPLDefBlock, "BorderOverride", szDisplayMsg )
   AddBlockAttribute( mSPLDefBlock, "Padding", szDisplayMsg )
   AddBlockAttribute( mSPLDefBlock, "PaddingTop", szDisplayMsg )
   AddBlockAttribute( mSPLDefBlock, "PaddingBottom", szDisplayMsg )
   AddBlockAttribute( mSPLDefBlock, "PaddingLeft", szDisplayMsg )
   AddBlockAttribute( mSPLDefBlock, "PaddingRight", szDisplayMsg )
   AddBlockAttribute( mSPLDefBlock, "PaddingOverride", szDisplayMsg )
   AddBlockAttribute( mSPLDefBlock, "TitlePosition", szDisplayMsg )
   AddBlockAttribute( mSPLDefBlock, "CapitalizeTitleTextFlag", szDisplayMsg )
   AddBlockAttribute( mSPLDefBlock, "TextAlign", szDisplayMsg )
   AddBlockAttribute( mSPLDefBlock, "TextLineHeight", szDisplayMsg )
   AddBlockAttribute( mSPLDefBlock, "TextLetterSpace", szDisplayMsg )
// AddBlockAttribute( mSPLDefBlock, "Depth", szDisplayMsg )
   AddBlockAttribute( mSPLDefBlock, "UsageColumn1BreakName", szDisplayMsg )
   AddBlockAttribute( mSPLDefBlock, "UsageColumn2BreakName", szDisplayMsg )
// AddBlockAttribute( mSPLDefBlock, "wRelativeBlockNumber", szDisplayMsg )
// AddBlockAttribute( mSPLDefBlock, "wComputedTopPosition", szDisplayMsg )
   lLth = zstrlen( szDisplayMsg )
   IF lLth > lMinLth
      TraceLineS( "Has data ", szDisplayMsg )
   ELSE
   IF bAll != 0
      TraceLineS( "~No data ", szDisplayMsg )
   END
   END
END

/////////////////////////////////////////////////////////////////////////////
//
//  OPERATION: FormatPrintIcons
//
/////////////////////////////////////////////////////////////////////////////
TRANSFORMATION OPERATION
FormatPrintIcons( VIEW mSPLDef BASED ON LOD mSPLDef,
                  INTEGER lFile,
                  STRING ( 32000 ) szWriteBuffer )

   DECIMAL PageHeight
   DECIMAL PageWidth
   DECIMAL TopMargin
   DECIMAL LeftMargin

   DECIMAL IconTopLeftTop
   DECIMAL IconBottomLeftTop
   DECIMAL IconTopRightTop
   DECIMAL IconBottomRightTop
   DECIMAL IconCenterTopTop
   DECIMAL IconCenterLeftTop
   DECIMAL IconCenterRightTop
   DECIMAL IconCenterBottomTop

   DECIMAL IconTopLeftLeft
   DECIMAL IconBottomLeftLeft
   DECIMAL IconTopRightLeft
   DECIMAL IconBottomRightLeft
   DECIMAL IconCenterTopLeft
   DECIMAL IconCenterLeftLeft
   DECIMAL IconCenterRightLeft
   DECIMAL IconCenterBottomLeft

   STRING ( 32 ) szTop
   STRING ( 32 ) szLeft
   STRING ( 30 ) szDateTime
   STRING ( 30 ) szDateTimeDisplay
   STRING ( 90 ) szProductIdentifier
   STRING ( 32 ) szLPLR_Name
   STRING ( 64 ) szSystemIniApplName
   STRING ( 256 ) szImageDirectory

   // Get the fop images directory
   SfGetApplicationForSubtask( szLPLR_Name, mSPLDef )
   szSystemIniApplName = "[App." + szLPLR_Name + "]"
   SysReadZeidonIni( -1, szSystemIniApplName, "FopImageDirectory", szImageDirectory )
   SysConvertEnvironmentString( szImageDirectory, szImageDirectory )
   SysAppendcDirSep( szImageDirectory )

   // Format the printer icons based on the Page Height and Width.

   // There are 4 corner icons and 4 Center line icons, all of which identify the boundaries of the panel images for the page.
   // The Panel area will be positioned 1 inch from the top and 1 inch from the left and 1 inch from the right and one inch from
   // the bottom. The 4 center line icons will be in the middle of those corner icons.
   //
   // The 4 corner icons will be positioned:
   //       TopLeft     Top:  0.2
   //                   Left: 0.2
   //       BottomLeft  Top:  PageHeight - 1.2
   //                   Left: 0.2
   //       TopRight    Top:  0.2
   //                   Left: PageWidth - 1.2
   //       BottomRight Top:  PageHeight - 1.2
   //                   Left: PageWidth - 1.2
   //
   // The 4 mid-point icons will be positioned:
   //       CenterTop    Top:  0.2
   //                    Left: (PageWidth - 2) / 2 + 0.2
   //       CenterLeft   Top:  (PageHeight - 2) / 2 + 0.2
   //                    Left: 0.2
   //       CenterRight  Top:  (PageHeight - 2) / 2 + 0.2
   //                    Left: PageWidth - 1.2
   //       CenterBottom Top:  PageHeight - 1.2
   //                    Left: (PageWidth - 2) / 2 + 0.2
   //
   // In addition, a PDF identifier showing company and date/time is displayed in upper left.

   SET CURSOR FIRST mSPLDef.LLD_Panel

   // Compute Top and Left icon margin values.

   TopMargin       = 1
   LeftMargin      = 1
   PageWidth      = mSPLDef.LLD_Page.Width + 2
   PageHeight     = mSPLDef.LLD_Page.Height + 2

   IconTopLeftTop         = 0.2
   IconTopLeftLeft        = 0.2

   IconBottomLeftTop      = PageHeight - 0.8
   IconBottomLeftLeft     = 0.2

   IconTopRightTop        = 0.2
   IconTopRightLeft       = PageWidth - 0.8

   IconBottomRightTop     = PageHeight - 0.8
   IconBottomRightLeft    = PageWidth - 0.8

   IconCenterTopTop       = 0.2
   IconCenterTopLeft      = (PageWidth - 2) / 2 + 0.2

   IconCenterLeftTop      = (PageHeight - 2) / 2 + 0.2
   IconCenterLeftLeft     = 0.2

   IconCenterRightTop     = (PageHeight - 2) / 2 + 0.2
   IconCenterRightLeft    = PageWidth - 0.8

   IconCenterBottomTop    = PageHeight - 0.8
   IconCenterBottomLeft   = (PageWidth - 2) / 2 + 0.2

   // Generate Icons

   szWriteBuffer = "               <!-- Printer Location Icon Generation -->"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

   // Icon Top Left
   szTop  = IconTopLeftTop
   szLeft = IconTopLeftLeft
   szWriteBuffer = "               <fo:block-container position=^absolute^ top=^" + szTop + "in^ left=^" + szLeft + "in^>"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )
   szWriteBuffer = "                  <fo:block text-align=^left^>"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )
   szWriteBuffer = "                     <fo:external-graphic src=^" + szImageDirectory + "/TopLeft.png^/>"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )
   szWriteBuffer = "                  </fo:block>"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )
   szWriteBuffer = "               </fo:block-container>"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

   // Icon Top Right
   szTop  = IconTopRightTop
   szLeft = IconTopRightLeft
   szWriteBuffer = "               <fo:block-container position=^absolute^ top=^" + szTop + "in^ left=^" + szLeft + "in^>"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )
   szWriteBuffer = "                  <fo:block text-align=^left^>"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )
   szWriteBuffer = "                     <fo:external-graphic src=^" + szImageDirectory + "/TopRight.png^/>"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )
   szWriteBuffer = "                  </fo:block>"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )
   szWriteBuffer = "               </fo:block-container>"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

   // Icon Bottom Left
   szTop  = IconBottomLeftTop
   szLeft = IconBottomLeftLeft
   szWriteBuffer = "               <fo:block-container position=^absolute^ top=^" + szTop + "in^ left=^" + szLeft + "in^>"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )
   szWriteBuffer = "                  <fo:block text-align=^left^>"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )
   szWriteBuffer = "                     <fo:external-graphic src=^" + szImageDirectory + "/BottomLeft.png^/>"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )
   szWriteBuffer = "                  </fo:block>"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )
   szWriteBuffer = "               </fo:block-container>"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

   // Icon Bottom Right
   szTop  = IconBottomRightTop
   szLeft = IconBottomRightLeft
   szWriteBuffer = "               <fo:block-container position=^absolute^ top=^" + szTop + "in^ left=^" + szLeft + "in^>"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )
   szWriteBuffer = "                  <fo:block text-align=^left^>"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )
   szWriteBuffer = "                     <fo:external-graphic src=^" + szImageDirectory + "/BottomRight.png^/>"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )
   szWriteBuffer = "                  </fo:block>"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )
   szWriteBuffer = "               </fo:block-container>"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

   // Icon Top Center
   szTop  = IconCenterTopTop
   szLeft = IconCenterTopLeft
   szWriteBuffer = "               <fo:block-container position=^absolute^ top=^" + szTop + "in^ left=^" + szLeft + "in^>"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )
   szWriteBuffer = "                  <fo:block text-align=^left^>"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )
   szWriteBuffer = "                     <fo:external-graphic src=^" + szImageDirectory + "/CenterH.png^/>"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )
   szWriteBuffer = "                  </fo:block>"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )
   szWriteBuffer = "               </fo:block-container>"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

   // Icon Bottom Center
   szTop  = IconCenterBottomTop
   szLeft = IconCenterBottomLeft
   szWriteBuffer = "               <fo:block-container position=^absolute^ top=^" + szTop + "in^ left=^" + szLeft + "in^>"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )
   szWriteBuffer = "                  <fo:block text-align=^left^>"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )
   szWriteBuffer = "                     <fo:external-graphic src=^" + szImageDirectory + "/CenterH.png^/>"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )
   szWriteBuffer = "                  </fo:block>"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )
   szWriteBuffer = "               </fo:block-container>"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

   // Icon Left Center
   szTop  = IconCenterLeftTop
   szLeft = IconCenterLeftLeft
   szWriteBuffer = "               <fo:block-container position=^absolute^ top=^" + szTop + "in^ left=^" + szLeft + "in^>"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )
   szWriteBuffer = "                  <fo:block text-align=^left^>"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )
   szWriteBuffer = "                     <fo:external-graphic src=^" + szImageDirectory + "/CenterV.png^/>"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )
   szWriteBuffer = "                  </fo:block>"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )
   szWriteBuffer = "               </fo:block-container>"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

   // Icon Right Center
   szTop  = IconCenterRightTop
   szLeft = IconCenterRightLeft
   szWriteBuffer = "               <fo:block-container position=^absolute^ top=^" + szTop + "in^ left=^" + szLeft + "in^>"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )
   szWriteBuffer = "                  <fo:block text-align=^left^>"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )
   szWriteBuffer = "                     <fo:external-graphic src=^" + szImageDirectory + "/CenterV.png^/>"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )
   szWriteBuffer = "                  </fo:block>"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )
   szWriteBuffer = "               </fo:block-container>"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

   // Company and Date/Time Identifier

   GetStringFromAttributeByContext( szDateTimeDisplay, mSPLDef, "SubregPhysicalLabelDef", "wDateTime", "YYYY/MM/DD HH:MM:SS.S AM", 30 )
   //szDateTimeDisplay = "01/01/2000 00:00:00.0 AM"
   szProductIdentifier = mSPLDef.SubregOrganization.Name + "   " + mSPLDef.MasterLabelContent.Version + ":" + mSPLDef.SubregLabelContent.Version + "   " + szDateTimeDisplay
   szWriteBuffer = "               <fo:block-container position=^absolute^ top=^0.4in^ left=^1.0in^>"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )
   szWriteBuffer = "                  <fo:block font-size=^7pt^ letter-spacing=^.2em^ text-align=^left^>"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )
   szWriteBuffer = "                     " + szProductIdentifier
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )
   szWriteBuffer = "                  </fo:block>"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )
   szWriteBuffer = "               </fo:block-container>"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

END

/////////////////////////////////////////////////////////////////////////////
//
//  OPERATION: FormatContinueBlock
//
/////////////////////////////////////////////////////////////////////////////
TRANSFORMATION OPERATION
FormatContinueBlock( VIEW mSPLDefPDF BASED ON LOD mSPLDef,
                     VIEW mSPLDef    BASED ON LOD mSPLDef,
                     INTEGER lFile,
                     STRING ( 50 )    szPassedBlanks,
                     STRING ( 32000 ) szWriteBuffer,
                     STRING ( 1 )     szContinueType )

   //VIEW mSPLDefPDFPrev BASED ON LOD mSPLDef
   STRING ( 32000 )  szStatementText
   STRING ( 32000 )  szTemporaryText
   STRING ( 256 )    szStatementTitle
   STRING ( 32 )     szSeparatorCharacters
   STRING ( 2 )      szTitleFormat
   STRING ( 2 )      szStatementFormat
   STRING ( 50 )     szSectionType
   STRING ( 50 )     szLeadingBlanks
   STRING ( 50 )     szDisplayStatementName
   STRING ( 50 )     szDisplaySectionName
   STRING ( 3 )      szDisplaySectionSuffix
   SHORT             nRC

   // Process Storage & Disposal, Directions For Use or Marketing Continuation Statements from previous Panel.

   szLeadingBlanks = szPassedBlanks

   // Create Block Container. Top is overridden to top of Panel.
// TraceLineS( "$$$$ Begin of FormatContinueBlock", "" )
//IF mSPLDef.ContinuationStatement DOES NOT EXIST
//   IssueError( mSPLDef,0,0, "stop" )
//END
//TraceLineS( "##########********** Continue Block: ", mSPLDefPDF.LLD_Block.LLD_SectionType )
//TraceLineS( "##########********** Format Continue: ", mSPLDef.ContinuationStatement.Text )

   FormatBlockContainer( mSPLDefPDF, mSPLDef, lFile, szLeadingBlanks, szWriteBuffer, "" )

   // If the continuation is to another Panel, put out Continuation text.
   IF szContinueType = "P"  // continuation is to another Panel
      // Add the Continuation verbage to the current Panel.
      szWriteBuffer = szLeadingBlanks + "   <fo:block margin-bottom=^.05in^>"
      WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

      IF mSPLDefPDF.LLD_Block.LLD_SectionType = "DirectionsForUse"
         szWriteBuffer = szLeadingBlanks + "      " + mSPLDefPDF.SPLD_LLD.ContNextPageTextDirForUse
      ELSE
         szWriteBuffer = szLeadingBlanks + "      " + mSPLDefPDF.SPLD_LLD.ContNextPageTextMarketing
      END
      WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

      szWriteBuffer = szLeadingBlanks + "   </fo:block>"
      WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )
   END

   szStatementFormat     = "SP"
   szSeparatorCharacters = ", "

   // Increment Display Section Suffix and Initialize DisplaySection entry.
   mSPLDef.SubregPhysicalLabelDef.wLastDisplaySuffixCount = mSPLDef.SubregPhysicalLabelDef.wLastDisplaySuffixCount + 1
   szDisplaySectionSuffix = mSPLDef.SubregPhysicalLabelDef.wLastDisplaySuffixCount
   szDisplaySectionName = "DisplaySection" + szDisplaySectionSuffix
   CREATE ENTITY mSPLDef.DisplaySection
   mSPLDef.DisplaySection.Type = "SPLD_ContinuationSection"
   mSPLDef.DisplaySection.XML_SectionName = szDisplaySectionName

   // If this is a continuation to the next Panel, we need to use the last block on the previous Panel for formatting, so create that view.
   /*CreateViewFromView( mSPLDefPDFPrev, mSPLDefPDF )
   NAME VIEW mSPLDefPDFPrev "mSPLDefPDFPrev"
   IF szContinueType = "P"
      SET CURSOR PREVIOUS mSPLDefPDFPrev.LLD_Panel
      SET CURSOR LAST mSPLDefPDFPrev.LLD_Block
   END*/

   // Format each Statement, with Title, if requested.
   FOR EACH mSPLDef.ContinuationStatement

      // Create the Display Statement entry, unless this Statement is a full continuation on next page.
      mSPLDef.SubregPhysicalLabelDef.wLastDisplaySuffixCount = mSPLDef.SubregPhysicalLabelDef.wLastDisplaySuffixCount + 1
      szDisplaySectionSuffix = mSPLDef.SubregPhysicalLabelDef.wLastDisplaySuffixCount
      szDisplayStatementName = "DisplayStatement" + szDisplaySectionSuffix
      CREATE ENTITY mSPLDef.DisplayStatement
      mSPLDef.DisplayStatement.XML_StatementName = szDisplayStatementName

      szStatementText  = mSPLDef.ContinuationStatement.Text
      szStatementTitle = mSPLDef.ContinuationStatement.Title
      IF szTitleFormat = "PU"

      ELSE

         IF szStatementFormat = "SN"   // SN - Separate Numbered Paragraph

            // This will be skipped for now.

            // Process each Statement within the Section, indenting any text that follows a number.
            // We will do this by determining if the first character in the text is a number.
            // If it is not, we'll simply format as for SP above.
            // If it is, we'll find the first character after any spaces following the number and indent that text, after the number.

         END
      END

      szSectionType = mSPLDefPDF.LLD_Block.LLD_SectionType

      // Combine Title in text if specified.
      IF szStatementTitle != "" AND szTitleFormat = "CT"
         // Title is combined with Text.
         szTemporaryText = szStatementText
         szStatementText = szStatementTitle + " " + szTemporaryText
      ELSE
         // Format Title, if it exists.
         IF szStatementTitle != ""
            szWriteBuffer = szLeadingBlanks + "   <fo:block "
            AddFormatToSpecialText( mSPLDefPDF, szSectionType, "Title", szWriteBuffer )
            WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

            //szWriteBuffer = szLeadingBlanks + "      " + szStatementTitle
            szWriteBuffer = szLeadingBlanks + "      <xsl:apply-templates select=^SubregPhysicalLabelDef/"
                                            + szDisplaySectionName + "/" + szDisplayStatementName + "/Title^/>"
            WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

            szWriteBuffer = szLeadingBlanks + "   </fo:block>"
            WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

            mSPLDef.DisplayStatement.Title = szStatementTitle
         END
      END

      // Format Statement Text
      szWriteBuffer = szLeadingBlanks + "   <fo:block "
      AddFormatToSpecialText( mSPLDefPDF, szSectionType, "Text", szWriteBuffer )
      WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

      //szWriteBuffer = szLeadingBlanks + "      " + szStatementText
      szWriteBuffer = szLeadingBlanks + "      <xsl:apply-templates select=^SubregPhysicalLabelDef/"
                                            + szDisplaySectionName + "/" + szDisplayStatementName + "/Text^/>"
      WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

      szWriteBuffer = szLeadingBlanks + "   </fo:block>"
      WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

      mSPLDef.DisplayStatement.Text = szStatementText

   END
   //DropView( mSPLDefPDFPrev )

   // Process Termination.
   szWriteBuffer = szLeadingBlanks + "</fo:block-container>"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

   // Remove any existing Continuation Statements.
   FOR EACH mSPLDef.ContinuationStatement
      DELETE ENTITY mSPLDef.ContinuationStatement NONE
   END

END

/////////////////////////////////////////////////////////////////////////////
//
//  OPERATION: ProcessPDF_Blocks
//
//    Note that mSPLDefPDF is pointing to the LLD Panel and Block substructure,
//    which recursively steps to a subblock, while mSPLDef points to the rest
//    of the structure at the root level.  mSPLDefTopBlock will be pointing to
//    the top Block structure, which will be the same as mSPLDefPDF unless
//    we've stepped down a level to SubBlock.  mSPLDefContinue is used to get
//    position on the Continuation block for a block that is continued.
//
/////////////////////////////////////////////////////////////////////////////
TRANSFORMATION OPERATION
ProcessPDF_Blocks( VIEW mSPLDef    BASED ON LOD mSPLDef,
                   VIEW mSPLDefPDF BASED ON LOD mSPLDef,
                   VIEW mSPLDefContinue BASED ON LOD mSPLDef,
                   INTEGER lFile,
                   STRING ( 50 )    szPassedBlanks,
                   STRING ( 32000 ) szWriteBuffer )

   VIEW mSPLDefTopBlock BASED ON LOD mSPLDef
   STRING ( 64 ) szTag
   STRING ( 50 ) szLeadingBlanks
   STRING ( 50 ) szBlockBlanks
   STRING ( 32 ) szHeight
   STRING ( 32 ) szWidth
   STRING ( 32 ) szTop
   STRING ( 50 ) szSectionType
   STRING ( 50 ) szLeft
   STRING ( 90 ) szTitle
   STRING ( 90 ) szMsg
   STRING ( 32 ) szLPLR_Name
   STRING ( 64 ) szSystemIniApplName
   STRING ( 256 ) szImageDirectory
   INTEGER       lControl
   SHORT         nRC

   szTag = mSPLDefPDF.LLD_Block.Tag
// TraceLineS( "Processing Block: ", szTag )
   // Process each LLD_Block Container and subobject data.

   szLeadingBlanks = szPassedBlanks + "   "

   // If the first LLD_Block is a Continuation LLD_Block from the previous Panel, process it first.
   IF mSPLDefPDF.LLD_Block.ContinuationBlockFlag = "Y" AND mSPLDefPDF.ContinuationStatement EXISTS
      // continuation is to another Panel ... put out Continuation text "ContNextPageText..."
      FormatContinueBlock( mSPLDefPDF, mSPLDef, lFile, szLeadingBlanks, szWriteBuffer, "P" )
   END

   FOR EACH mSPLDefPDF.LLD_Block
//TraceLineS( "##########********** Block: ", mSPLDefPDF.LLD_Block.LLD_SectionType )
//TraceLineS( "##########********** ContinuationBlockFlag: ", mSPLDefPDF.LLD_Block.ContinuationBlockFlag )

      szTag = mSPLDefPDF.LLD_Block.Tag
      IF mSPLDefPDF.LLD_Block.ContinuationBlockFlag = "Y"
      // TraceLineS( "Processing Continued Block: ", szTag )
      // IF szTag = "Tag666"
      //    TraceLineS( "Processing skip tag: ", szTag )
      // END
         // This is a continuation from the last Block, so format if there is continuation data.
         // Note that mSPLDef is pointing to the Panel entity that holds the continuation statements.
         SET CURSOR FIRST mSPLDef.ContinuationStatement
         IF RESULT >= zCURSOR_SET
            FormatContinueBlock( mSPLDefPDF, mSPLDef, lFile, szLeadingBlanks, szWriteBuffer, "B" )  // continuation from the last Block
//TraceLineS( "##########********** FormatContinueBlock ", mSPLDefPDF.LLD_Block.ContinuationBlockFlag )

            // Remove continuation entries.
            FOR EACH mSPLDef.ContinuationStatement
               DELETE ENTITY mSPLDef.ContinuationStatement NONE
            END
//         ELSE
//  IssueError( mSPLDef,0,0, "stop" )
         END

      ELSE
      // TraceLineS( "Processing Normal Block: ", szTag )

         // Create LLD_Block Container.
         FormatBlockContainer( mSPLDefPDF, mSPLDef, lFile, szLeadingBlanks, szWriteBuffer, "" )

         // Processing depends on which kind of LLD_Block this is.
         // If it is just a Container, then format the LLD_Block and process each LLD_SubBlock.
         // Otherwise, go to the proper suboperation for processing the type of LLD_Block.
         IF mSPLDefPDF.LLD_SubBlock EXISTS
            // Process each LLD_SubBlock as regular Block, after stepping into subobject.

            // Create a view to the top Block for debug purposes.
            CreateViewFromView( mSPLDefTopBlock, mSPLDefPDF )
            SetViewToSubobject( mSPLDefPDF, "LLD_SubBlock" )

            // Recursive call to ProcessPDF_Blocks
            nRC = ProcessPDF_Blocks( mSPLDef, mSPLDefPDF, mSPLDefContinue, lFile, szLeadingBlanks, szWriteBuffer )
            IF nRC = 2
               RETURN 2
            END
            ResetViewFromSubobject( mSPLDefPDF )

            GET VIEW mSPLDefTopBlock NAMED "mSPLDefTopBlock"
            IF RESULT >= 0
               DropView( mSPLDefTopBlock )
            END

         ELSE
            // Determine what kind of LLD_Block it is and go to process accordingly.
            szSectionType = mSPLDefPDF.LLD_Block.LLD_SectionType

            // IMAGE
            IF szSectionType = "Graphic"

               // Get the fop images directory
               SfGetApplicationForSubtask( szLPLR_Name, mSPLDef )
               szSystemIniApplName = "[App." + szLPLR_Name + "]"
               SysReadZeidonIni( -1, szSystemIniApplName, "FopImageDirectory", szImageDirectory )
               SysConvertEnvironmentString( szImageDirectory, szImageDirectory )
               SysAppendcDirSep( szImageDirectory )

               szHeight = mSPLDefPDF.LLD_Block.Height
               szWidth  = mSPLDefPDF.LLD_Block.Width
               szTop    = mSPLDefPDF.LLD_Block.Top
               szLeft   = mSPLDefPDF.LLD_Block.Left

               szWriteBuffer = "                     <fo:block text-align=^left^>"
               WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )
               szWriteBuffer = "                        <fo:external-graphic src=^" + szImageDirectory + mSPLDefPDF.LLD_Block.ImageName +
                               "^ height=^" + szHeight + "in^ width=^" + szWidth + "in^ content-height=^scale-to-fit^ content-width=^scale-to-fit^/>"
               WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

               szWriteBuffer = "                     </fo:block>"
               WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

            ELSE

            // DIRECTIONS FOR USE
            IF szSectionType = "DirectionsForUse"
            // TraceLineS( "Major Block: ", szSectionType )

               // Check if Title should be converted to upper case.
               szTitle = "Directions For Use"
               SET CURSOR FIRST mSPLDefPDF.LLD_SpecialSectionAttribute WHERE mSPLDefPDF.LLD_SpecialSectionAttribute.Name = "Header"
               IF RESULT >= zCURSOR_SET
                  szTitle = "DIRECTIONS FOR USE"
               END

               // Set up Directions For Use Title.
               szWriteBuffer = szLeadingBlanks + "   <fo:block "
               AddFormatToSpecialText( mSPLDefPDF, szSectionType, "Header", szWriteBuffer )
               WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

               szWriteBuffer = szLeadingBlanks + "      " + szTitle
               WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

               szWriteBuffer = szLeadingBlanks + "   </fo:block>"
               WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

               // For Directions For Use, we will process all Sections.
               FOR EACH mSPLDef.SPLD_DirectionsForUseCategory
                  FOR EACH mSPLDef.SPLD_DirectionsForUseSection
                     GeneratePDF_DFU( mSPLDef, mSPLDefPDF, lFile,
                                      szSectionType,
                                      "SPLD_DirectionsForUseSection",
                                      "SPLD_DirectionsForUseStatement",
                                      "SPLD_DirectionsUsage",
                                      "SPLD_DirectionsUsageOrdering",
                                      szLeadingBlanks,
                                      szWriteBuffer )
                  END
               END
            ELSE

            // MARKETING
            IF szSectionType = "Marketing"
            // TraceLineS( "Major Block: ", szSectionType )

               // For Marketing, we will process a Section if its Name matches the name in the Block.
               SET CURSOR FIRST mSPLDef.SPLD_MarketingSection WHERE mSPLDef.SPLD_MarketingSection.Name = mSPLDefPDF.LLD_Block.Name
               IF RESULT >= zCURSOR_SET
               // There are no Marketing headers ... Don - 2015.05.12
               // // If there is a Marketing "Header" entry, add it.
               // SET CURSOR FIRST mSPLDefPDF.LLD_SpecialSectionAttribute WHERE mSPLDefPDF.LLD_SpecialSectionAttribute.Name = "Header"
               // IF RESULT >= zCURSOR_SET
               //    szWriteBuffer = szLeadingBlanks + "   <fo:block "
               //    AddFormatToSpecialText( mSPLDefPDF, szSectionType, "Header", szWriteBuffer )
               //    WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )
               //    szWriteBuffer = szLeadingBlanks + "      Marketing"
               //    WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )
               //    szWriteBuffer = szLeadingBlanks + "   </fo:block>"
               //    WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )
               // END
               //
                  // Don't execute if the only Statement is null. This could occur if the block contains a Claims List, without
                  // any marketing statement preceding it.
                  IF mSPLDef.SPLD_MarketingStatement.Text != ""
                     GeneratePDF_DFU( mSPLDef, mSPLDefPDF, lFile,
                                      szSectionType,
                                      "SPLD_MarketingSection",
                                      "SPLD_MarketingStatement",
                                      "SPLD_MarketingUsage",
                                      "SPLD_MarketingUsageOrdering",
                                      szLeadingBlanks,
                                      szWriteBuffer )
                  END
               ELSE
                  IF mSPLDefPDF.LLD_Block.Name = ""
                     szMsg = "Marketing Section Name for Block is null."
                  ELSE
                     szMsg = "No match on Marketing Section Name: " + mSPLDefPDF.LLD_Block.Name
                  END
                  //CreateViewFromView( mSPLDefPDF2, mSPLDefPDF )
                  //NAME VIEW mSPLDefPDF2 "mSPLDefPDFBlock"
                  MessageSend( mSPLDef, "", "Generate Label", szMsg, zMSGQ_OBJECT_CONSTRAINT_ERROR, 0 )
                  //DropView( mSPLDefPDF2 )
                  RETURN 2
               END
            ELSE

               // GENERAL (ENVIRONMENTAL/PHYSICAL HAZARD, FIRST AID or PRECAUTIONARY)
            // IF szSectionType = "OtherHazard" OR
            //    szSectionType = "FirstAid" OR
            //    szSectionType = "Precautionary"
            //  // We can get by using the same operation because all 3 Section Types are handled the same way and the child entity,
            //  // SPLDT_GeneralSection, is pointing to the instance of the correct Type.
            //    TraceLineS( "Major Block: ", szSectionType )
            //    FOR EACH mSPLDef.SPLDT_GeneralSection
            //       GeneratePDF_General( mSPLDef, mSPLDefPDF, lFile, szLeadingBlanks, szWriteBuffer )
            //    END
            // ELSE

            // STORAGE AND DISPOSAL
            IF szSectionType = "StorageDisposal"

            // TraceLineS( "Major Block: ", szSectionType )
               GeneratePDF_DFU( mSPLDef, mSPLDefPDF, lFile,
                                szSectionType,
                                "SPLD_StorageDisposalSection",
                                "SPLD_StorageDisposalStatement",
                                "",
                                "",
                                szLeadingBlanks,
                                szWriteBuffer )

            ELSE

            // PRECAUTIONARY
            IF szSectionType = "Precautionary"

            // TraceLineS( "Major Block: ", szSectionType )
               SET CURSOR FIRST mSPLDef.SPLD_GeneralSection WHERE mSPLDef.SPLD_GeneralSection.SectionType = "P"  // SectionType of P is Precautionary
               GeneratePDF_DFU( mSPLDef, mSPLDefPDF, lFile,
                                szSectionType,
                                "SPLD_GeneralSection",
                                "SPLD_GeneralStatement",
                                "",
                                "",
                                szLeadingBlanks,
                                szWriteBuffer )

            ELSE

            // FIRST AID
            IF szSectionType = "FirstAid"

            // TraceLineS( "Major Block: ", szSectionType )

               // Check if Title should be converted to upper case.
               szTitle = "First Aid"
               SET CURSOR FIRST mSPLDefPDF.LLD_SpecialSectionAttribute WHERE mSPLDefPDF.LLD_SpecialSectionAttribute.Name = "Header"
               IF RESULT >= zCURSOR_SET
                  szTitle = "FIRST AID"
               END

               // Set up First Aid Title.
               szWriteBuffer = szLeadingBlanks + "   <fo:block "
               AddFormatToSpecialText( mSPLDefPDF, szSectionType, "Header", szWriteBuffer )
               WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

               szWriteBuffer = szLeadingBlanks + "      " + szTitle
               WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

               szWriteBuffer = szLeadingBlanks + "   </fo:block>"
               WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

               SET CURSOR FIRST mSPLDef.SPLD_GeneralSection WHERE mSPLDef.SPLD_GeneralSection.SectionType = "F"  // SectionType of F is First Aid
               GeneratePDF_DFU( mSPLDef, mSPLDefPDF, lFile,
                                szSectionType,
                                "SPLD_GeneralSection",
                                "SPLD_GeneralStatement",
                                "",
                                "",
                                szLeadingBlanks,
                                szWriteBuffer )

            ELSE

            // ENVIRONMENTAL/PHYSICAL HAZARD
            IF szSectionType = "EnvironmentalHazard"

            // TraceLineS( "Major Block: ", szSectionType )
               SET CURSOR FIRST mSPLDef.SPLD_GeneralSection WHERE mSPLDef.SPLD_GeneralSection.SectionType = "E"  // SectionType of E is Environmental Hazard
               GeneratePDF_DFU( mSPLDef, mSPLDefPDF, lFile,
                                szSectionType,
                                "SPLD_GeneralSection",
                                "SPLD_GeneralStatement",
                                "",
                                "",
                                szLeadingBlanks,
                                szWriteBuffer )

            ELSE

            // HUMAN HAZARD
            IF szSectionType = "HumanHazard"

               // Generate the single Hazards entry.
            // TraceLineS( "Major Block: ", szSectionType )
               GeneratePDF_Hazards( mSPLDef, mSPLDefPDF, lFile, szSectionType, szLeadingBlanks, szWriteBuffer )

            ELSE

            // INGREDIENTS
            IF szSectionType = "Ingredients"

               // Go to generate Active Ingredients.
            // TraceLineS( "Major Block: ", szSectionType )
               GeneratePDF_Ingred( mSPLDef, mSPLDefPDF, lFile, szSectionType, szLeadingBlanks, szWriteBuffer )

            ELSE

            // NET CONTENTS
            IF szSectionType = "NetContents"

               // Go to generate Net Contents.
            // TraceLineS( "Major Block: ", szSectionType )
               GeneratePDF_Content( mSPLDef, mSPLDefPDF, lFile, szSectionType, szLeadingBlanks, szWriteBuffer )

            ELSE

            // EPA REGISTRATION AND ESTABLISHMENT NUMBERS
            IF szSectionType = "EPA_RegAndEstNbr"

               // Go to generate EPA Reg and Est Numbers.
            // TraceLineS( "Major Block: ", szSectionType )
               GeneratePDF_EPA_Reg( mSPLDef, mSPLDefPDF, lFile, szSectionType, szLeadingBlanks, szWriteBuffer )

            ELSE

            // PRODUCT NAME
            IF szSectionType = "ProductName"

            // TraceLineS( "Major Block: ", szSectionType )
               szBlockBlanks = szLeadingBlanks + "   "
               szWriteBuffer = szBlockBlanks + "<fo:block "
               AddFormatToSpecialText( mSPLDefPDF, szSectionType, "Text", szWriteBuffer )
               WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

               szWriteBuffer = szBlockBlanks + "   <xsl:apply-templates select=^SubregPhysicalLabelDef/ProductName^/>"
               WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

               szWriteBuffer = szBlockBlanks + "</fo:block>"
               WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

            ELSE

            // PRODUCT DESCRIPTION
            IF szSectionType = "Product Description"

            // TraceLineS( "Major Block: ", szSectionType )
               szBlockBlanks = szLeadingBlanks + "   "
               szWriteBuffer = szBlockBlanks + "<fo:block>"
               WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

               szWriteBuffer = szBlockBlanks + "   <xsl:apply-templates select=^SubregPhysicalLabelDef/SubregLabelContent/SubregProduct/Description^/>"
               WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

               szWriteBuffer = szBlockBlanks + "</fo:block>"
               WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )
            ELSE
               // It is an error because there is no processing for the Block.

               szMsg = "The Block is empty for Panel: " + mSPLDef.LLD_Panel.Tag + ", Block: " + mSPLDefPDF.LLD_Block.Tag + "."
               TraceLineS( szMsg, "" )

               szTitle = "Error:"

               // Set up Error Title.
               szWriteBuffer = szLeadingBlanks + "   <fo:block>"
               WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

               szWriteBuffer = szLeadingBlanks + "      " + szTitle + "   " + szMsg
               WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

               szWriteBuffer = szLeadingBlanks + "   </fo:block>"
               WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

            // MessageSend( mSPLDef, "", "Generate Label", szMsg, zMSGQ_OBJECT_CONSTRAINT_ERROR, 0 )
            // RETURN 2
            END
            END
            END
            END
            END
            END
            END
            END
            END
            END
            END
            END
            END

            // Add Column list for Marketing Section, if requested.
            IF szSectionType = "Marketing" AND mSPLDefPDF.LLD_Block.LLD_ColumnListType != ""
               IF mSPLDefPDF.LLD_Block.LLD_ColumnListType = "C3"
                  // Request is 3 Column Claim List.
               // TraceLineS( "Marketing 3-Column List ", "" )
                  GeneratePDF_ClmList( mSPLDef, mSPLDefPDF, lFile, szSectionType, szLeadingBlanks, szWriteBuffer, 3 )
               ELSE
                  // Default is 2 Column Claim List.
               // TraceLineS( "Marketing 2-Column List ", "" )
                  GeneratePDF_ClmList( mSPLDef, mSPLDefPDF, lFile, szSectionType, szLeadingBlanks, szWriteBuffer, 2 )
               END
            END
         END

         // Process Termination.
         szWriteBuffer = szLeadingBlanks + "</fo:block-container>"
         WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )
//?
//       szTag = mSPLDefPDF.LLD_Block.ContinuationBlockTag
//       IF szTag != ""
//          lControl = zQUAL_STRING + zPOS_FIRST + zQUAL_SCOPE_OI
//          IF SetEntityCursor( mSPLDefContinue, "LLD_Block", "Tag", lControl, szTag, "", "", 0, "", "" ) >= zCURSOR_SET
//
//             IF mSPLDefContinue.LLD_Block.ContinuationBlockFlag = "Y" AND mSPLDefContinue.ContinuationStatement EXISTS
//                FormatContinueBlock( mSPLDefContinue, mSPLDef, lFile, szLeadingBlanks, szWriteBuffer, "B" )
//             END
//          END
//      END
//?
      END
   END
END

/////////////////////////////////////////////////////////////////////////////
//
//  OPERATION: FormatBlockContainer
//
//  this formats the fo:block-container
//
/////////////////////////////////////////////////////////////////////////////
TRANSFORMATION OPERATION
FormatBlockContainer( VIEW mSPLDefPDF BASED ON LOD mSPLDef,
                      VIEW mSPLDef    BASED ON LOD mSPLDef,
                      INTEGER lFile,
                      STRING ( 50 )    szLeadingBlanks,
                      STRING ( 32000 ) szWriteBuffer,
                      STRING ( 32 )    szTopPosition )

   STRING ( 32 )  szTop
   STRING ( 32 )  szHeight
   STRING ( 32 )  szWidth
   STRING ( 32 )  szLeft
   STRING ( 32 )  szBorderStyle
   STRING ( 32 )  szColor
   STRING ( 32 )  szFontFamily
   STRING ( 32 )  szFontSize
   STRING ( 32 )  szDefaultFontSize
   STRING ( 32 )  szFontWeight
   STRING ( 32 )  szMBP
   STRING ( 32 )  szTopMBP
   STRING ( 32 )  szBottomMBP
   STRING ( 32 )  szLeftMBP
   STRING ( 32 )  szRightMBP
   STRING ( 32 )  szTextAlign
   STRING ( 256 ) szImg

   STRING ( 512 ) szDebugMsg

// szDebugMsg = mSPLDefPDF.LLD_Block.ID
// szDebugMsg = szDebugMsg + "   Tag: " + mSPLDefPDF.LLD_Block.Tag
// szDebugMsg = szDebugMsg + "   Name: " + mSPLDefPDF.LLD_Block.Name
// szDebugMsg = szDebugMsg + "   Title: " + mSPLDefPDF.LLD_Block.BlockTitle
// szDebugMsg = szDebugMsg + "   Section Type: " + mSPLDefPDF.LLD_Block.LLD_SectionType
// TraceLineS( "FormatBlockContainer ID: ",  szDebugMsg )
// DisplayBlockAttributes( mSPLDefPDF, 1 )

   // Default font size will be set to 8pt for now.
   szDefaultFontSize = "8"

   // Process a Block and its subcomponents, which builds the XSL statement for the Container.
   // Note that mSPLDefPDF is addressing ONLY the LLD subobject and that this subobject could be in a temporary
   // object where that LLD subobject is the only thing valid in that object.

   szWriteBuffer = szLeadingBlanks + "<fo:block-container position=^absolute^"

   IF mSPLDefPDF.BlockBackgroundColor EXISTS
      szColor = mSPLDefPDF.BlockBackgroundColor.RGB
      IF szColor != ""
         szWriteBuffer = szWriteBuffer + " background-color=^#" + szColor + "^"
      END
   END

   IF mSPLDefPDF.BlockBorderColor EXISTS
      szColor = mSPLDefPDF.BlockBorderColor.RGB
      IF szColor != ""
         szWriteBuffer = szWriteBuffer + " border-color=^#" + szColor + "^"
      END
   END

   szBorderStyle = mSPLDefPDF.LLD_Block.BorderStyle
   IF szBorderStyle != ""
      szWriteBuffer = szWriteBuffer + " border-style=^" + szBorderStyle + "^"
   END

   szWidth = mSPLDefPDF.LLD_Block.BorderWidth
   IF szWidth != ""
      szWriteBuffer = szWriteBuffer + " border-width=^" + szWidth + "px^"
   END

   // Block Container Start, which is either passed in or specified in Block.
   // 1. It is passed in as last parameter.
   // 2. It is specified in Computed Top attribute.
   IF szTopPosition != ""
      szTop = szTopPosition
   ELSE
      szTop = mSPLDefPDF.LLD_Block.wComputedTopPosition
   END
   //szTop = mSPLDefPDF.LLD_Block.Top ... commented out because it is either passed in or calculated
   IF szTop != ""
      szWriteBuffer = szWriteBuffer + " top=^" + szTop + "in^"
   END

   szHeight = mSPLDefPDF.LLD_Block.Height
   IF szHeight != ""
      szWriteBuffer = szWriteBuffer + " height=^" + szHeight + "in^"
   END

   szWidth = mSPLDefPDF.LLD_Block.Width
   IF szWidth != ""
      szWriteBuffer = szWriteBuffer + " width=^" + szWidth + "in^"
   END

   szLeft = mSPLDefPDF.LLD_Block.Left
   IF szLeft != ""
      szWriteBuffer = szWriteBuffer + " left=^" + szLeft + "in^"
   END

   // Other Block parameters come from the "Block" LLD_SpecialSectionAttrBlock entry, if there is one.
   SET CURSOR FIRST mSPLDefPDF.LLD_SpecialSectionAttribute WHERE mSPLDefPDF.LLD_SpecialSectionAttribute.Name = "Block"
   IF RESULT >= zCURSOR_SET
      szFontFamily = mSPLDefPDF.LLD_SpecialSectionAttrBlock.FontFamily
   // TraceLineS( "1Font Family set to: ", szFontFamily )
      IF szFontFamily != ""
         szWriteBuffer = szWriteBuffer + " font-family=^" + szFontFamily + "^"
      END
      szFontSize = mSPLDefPDF.LLD_SpecialSectionAttrBlock.FontSize
      IF szFontSize != ""
   // TraceLineS( "1Font Size set to: ", szFontSize )
         szWriteBuffer = szWriteBuffer + " font-size=^" + szFontSize + "pt^"
      END
      szFontWeight = mSPLDefPDF.LLD_SpecialSectionAttrBlock.FontWeight
      IF szFontWeight != ""
         szWriteBuffer = szWriteBuffer + " font-weight=^" + szFontWeight + "^"
      END

      szMBP = mSPLDefPDF.LLD_SpecialSectionAttrBlock.Margin
      IF szMBP = ""
         szTopMBP = mSPLDefPDF.LLD_SpecialSectionAttrBlock.MarginTop
         IF szTopMBP != ""
            szWriteBuffer = szWriteBuffer + " margin-top=^" + szTopMBP + "in^"
         END
         szBottomMBP = mSPLDefPDF.LLD_SpecialSectionAttrBlock.MarginBottom
         IF szBottomMBP != ""
            szWriteBuffer = szWriteBuffer + " margin-bottom=^" + szBottomMBP + "in^"
         END
         szLeftMBP = mSPLDefPDF.LLD_SpecialSectionAttrBlock.MarginLeft
         IF szLeftMBP != ""
            szWriteBuffer = szWriteBuffer + " margin-left=^" + szLeftMBP + "in^"
         END
         szRightMBP = mSPLDefPDF.LLD_SpecialSectionAttrBlock.MarginRight
         IF szRightMBP != ""
            szWriteBuffer = szWriteBuffer + " margin-right=^" + szRightMBP + "in^"
         END
      ELSE
         szWriteBuffer = szWriteBuffer + " margin=^" + szMBP + "in^"
      END

      szMBP = mSPLDefPDF.LLD_SpecialSectionAttrBlock.Border
      IF szMBP = ""
         szTopMBP = mSPLDefPDF.LLD_SpecialSectionAttrBlock.BorderTop
         IF szTopMBP != ""
            szWriteBuffer = szWriteBuffer + " border-top=^" + szTopMBP + "in^"
         END
         szBottomMBP = mSPLDefPDF.LLD_SpecialSectionAttrBlock.BorderBottom
         IF szBottomMBP != ""
            szWriteBuffer = szWriteBuffer + " border-bottom=^" + szBottomMBP + "in^"
         END
         szLeftMBP = mSPLDefPDF.LLD_SpecialSectionAttrBlock.BorderLeft
         IF szLeftMBP != ""
            szWriteBuffer = szWriteBuffer + " border-left=^" + szLeftMBP + "in^"
         END
         szRightMBP = mSPLDefPDF.LLD_SpecialSectionAttrBlock.BorderRight
         IF szRightMBP != ""
            szWriteBuffer = szWriteBuffer + " border-right=^" + szRightMBP + "in^"
         END
      ELSE
         szWriteBuffer = szWriteBuffer + " border=^" + szMBP + "in^"
      END

      szMBP = mSPLDefPDF.LLD_SpecialSectionAttrBlock.Padding
      IF szMBP = ""
         szTopMBP = mSPLDefPDF.LLD_SpecialSectionAttrBlock.PaddingTop
         IF szTopMBP != ""
            szWriteBuffer = szWriteBuffer + " padding-top=^" + szTopMBP + "in^"
         END
         szBottomMBP = mSPLDefPDF.LLD_SpecialSectionAttrBlock.PaddingBottom
         IF szBottomMBP != ""
            szWriteBuffer = szWriteBuffer + " padding-bottom=^" + szBottomMBP + "in^"
         END
         szLeftMBP = mSPLDefPDF.LLD_SpecialSectionAttrBlock.PaddingLeft
         IF szLeftMBP != ""
            szWriteBuffer = szWriteBuffer + " padding-left=^" + szLeftMBP + "in^"
         END
         szRightMBP = mSPLDefPDF.LLD_SpecialSectionAttrBlock.PaddingRight
         IF szRightMBP != ""
            szWriteBuffer = szWriteBuffer + " padding-right=^" + szRightMBP + "in^"
         END
      ELSE
         szWriteBuffer = szWriteBuffer + " padding=^" + szMBP + "in^"
      END

      szTextAlign = mSPLDefPDF.LLD_SpecialSectionAttrBlock.TextAlign
      IF szTextAlign != ""
         szWriteBuffer = szWriteBuffer + " text-align=^" + szTextAlign + "^"
      END
   END

   // Add dotted border if requested, unless regular border is specified.
   IF szBorderStyle = "" AND mSPLDef.SubregPhysicalLabelDef.wFormatWithDottedBorders = "Y"
      szWriteBuffer = szWriteBuffer + " border=^1.0pt dotted red^"
   END

   // Add default font size of 8pt, if font wasn't specified above.
   IF szFontSize = ""
      szWriteBuffer = szWriteBuffer + " font-size=^" + szDefaultFontSize + "pt^"
   END

   // Close the entry.
   szWriteBuffer = szWriteBuffer + ">"

   // Write out the combined Block value.
   WL_QC( mSPLDefPDF, lFile, szWriteBuffer, "^", 0 )

END

/////////////////////////////////////////////////////////////////////////////
//
//  OPERATION: FormatBlock
//
/////////////////////////////////////////////////////////////////////////////
TRANSFORMATION OPERATION
FormatBlock( VIEW mSPLDef BASED ON LOD mSPLDef,
             INTEGER lFile,
             STRING ( 50 )    szLeadingBlanks,
             STRING ( 32000 ) szWriteBuffer )

   STRING ( 32 )  szTop
   STRING ( 32 )  szHeight
   STRING ( 32 )  szWidth
   STRING ( 32 )  szLeft
   STRING ( 32 )  szBorderStyle
   STRING ( 32 )  szColor
   STRING ( 32 )  szFontFamily
   STRING ( 32 )  szFontSize
   STRING ( 32 )  szFontWeight
   STRING ( 32 )  szMarginTop
   STRING ( 32 )  szMarginBottom
   STRING ( 32 )  szMarginLeft
   STRING ( 32 )  szMarginRight
   STRING ( 32 )  szTextAlign
   STRING ( 256 ) szImg
   // Process a Block and its subcomponents.
   // Block Container Start
   szWriteBuffer = szLeadingBlanks + "<fo:block"

   IF mSPLDef.BlockBackgroundColor EXISTS
      szColor = mSPLDef.BlockBackgroundColor.RGB
      IF szColor != ""
         szWriteBuffer = szWriteBuffer + " background-color=^#" + szColor + "^"
      END
   END

   IF mSPLDef.BlockBorderColor EXISTS
      szColor = mSPLDef.BlockBorderColor.RGB
      IF szColor != ""
         szWriteBuffer = szWriteBuffer + " border-color=^#" + szColor + "^"
      END
   END

   szBorderStyle = mSPLDef.LLD_Block.BorderStyle
   IF szBorderStyle != ""
      szWriteBuffer = szWriteBuffer + " border-style=^" + szBorderStyle + "^"
   END

   szWidth = mSPLDef.LLD_Block.BorderWidth
   IF szWidth != ""
      szWriteBuffer = szWriteBuffer + " border-width=^" + szWidth + "px^"
   END

   szTop = mSPLDef.LLD_Block.Top
   IF szTop != ""
      szWriteBuffer = szWriteBuffer + " top=^" + szTop + "in^"
   END

   szHeight = mSPLDef.LLD_Block.Height
   IF szHeight != ""
      szWriteBuffer = szWriteBuffer + " height=^" + szHeight + "in^"
   END

   szWidth = mSPLDef.LLD_Block.Width
   IF szWidth != ""
      szWriteBuffer = szWriteBuffer + " width=^" + szWidth + "in^"
   END

   szLeft = mSPLDef.LLD_Block.Left
   IF szLeft != ""
      szWriteBuffer = szWriteBuffer + " left=^" + szLeft + "in^"
   END


   szFontFamily = mSPLDef.LLD_Block.FontFamily
   IF szFontFamily != ""
   // TraceLineS( "2Font Family skipped: ", szFontFamily )
   // szWriteBuffer = szWriteBuffer + " font-family=^" + szFontFamily + "^"
   END
//
// szFontSize = mSPLDef.LLD_Block.FontSize
// IF szFontSize != ""
//    TraceLineS( "2Font Size set to: ", szFontSize )
//    szWriteBuffer = szWriteBuffer + " font-size=^" + szFontSize + "pt^"
// END
// szFontWeight = mSPLDef.LLD_Block.FontWeight
// IF szFontWeight != ""
//    szWriteBuffer = szWriteBuffer + " font-weight=^" + szFontWeight + "^"
// END
// szMarginTop = mSPLDef.LLD_Block.MarginTop
// IF szMarginTop != ""
//    szWriteBuffer = szWriteBuffer + " margin-top=^" + szMarginTop + "in^"
// END
// szMarginBottom = mSPLDef.LLD_Block.MarginBottom
// IF szMarginBottom != ""
//    szWriteBuffer = szWriteBuffer + " margin-bottom=^" + szMarginBottom + "in^"
// END
// szMarginLeft = mSPLDef.LLD_Block.MarginLeft
// IF szMarginLeft != ""
//    szWriteBuffer = szWriteBuffer + " margin-left=^" + szMarginLeft + "in^"
// END
// szMarginRight = mSPLDef.LLD_Block.MarginRight
// IF szMarginRight != ""
//    szWriteBuffer = szWriteBuffer + " margin-right=^" + szMarginRight + "in^"
// END
// szTextAlign = mSPLDef.LLD_Block.TextAlign
// IF szTextAlign != ""
//    szWriteBuffer = szWriteBuffer + " text-align=^" + szTextAlign + "^"
// END
//

   // Close the entry.
   szWriteBuffer = szWriteBuffer + ">"

   // Write out the combined Block value.
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

END

/////////////////////////////////////////////////////////////////////////////
//
//  OPERATION: AddFormatToSpecialText
//
/////////////////////////////////////////////////////////////////////////////
TRANSFORMATION OPERATION
AddFormatToSpecialText( VIEW mSPLDef BASED ON LOD mSPLDef,
                        STRING ( 50 )    szSectionType,
                        STRING ( 32 )    SpecialTextTitle,
                        STRING ( 32000 ) szWriteBuffer )

   STRING ( 32 )  szTop
   STRING ( 32 )  szHeight
   STRING ( 32 )  szWidth
   STRING ( 32 )  szLeft
   STRING ( 32 )  szBorderStyle
   STRING ( 32 )  szColor
   STRING ( 32 )  szFontFamily
   STRING ( 32 )  szFontSize
   STRING ( 32 )  szFontWeight
   STRING ( 32 )  szMBP
   STRING ( 32 )  szTopMBP
   STRING ( 32 )  szBottomMBP
   STRING ( 32 )  szLeftMBP
   STRING ( 32 )  szRightMBP
   STRING ( 32 )  szTextAlign
   STRING ( 32 )  szLineHeight
   STRING ( 32 )  szLetterSpace
   STRING ( 200 ) szMsg
   STRING ( 256 ) szImg
   SHORT nRC

   // Add any Special Attribute Block formatting variables to the text statement passed in szWriteBuffer.
   // Skip if the Special Text Attribute hasn't been defined.

   NAME VIEW mSPLDef "mSPLDefHazards"
// TraceLineS( "$$$$ Special Text for: ", SpecialTextTitle )
   SET CURSOR FIRST mSPLDef.LLD_SpecialSectionAttribute WHERE mSPLDef.LLD_SpecialSectionAttribute.Name = szSectionType
   IF RESULT >= zCURSOR_SET
      SET CURSOR FIRST mSPLDef.LLD_SpecialSectionAttrBlock WHERE mSPLDef.LLD_SpecialSectionAttrBlock.Name = SpecialTextTitle
      IF RESULT >= zCURSOR_SET

         IF mSPLDef.SpecialAttributeTextColor EXISTS
            szColor = mSPLDef.SpecialAttributeTextColor.RGB
            IF szColor != ""
               szWriteBuffer = szWriteBuffer + " color=^#" + szColor + "^"
            END
         END

         szFontFamily = mSPLDef.LLD_SpecialSectionAttrBlock.FontFamily
      // TraceLineS( "3Font Family set to: ", szFontFamily )
         IF szFontFamily != ""
            szWriteBuffer = szWriteBuffer + " font-family=^" + szFontFamily + "^"
         END

         szFontSize = mSPLDef.LLD_SpecialSectionAttrBlock.FontSize
         IF szFontSize != ""
         // TraceLineS( "3Font Size set to: ", szFontSize )
            szWriteBuffer = szWriteBuffer + " font-size=^" + szFontSize + "pt^"
         END

         szFontWeight = mSPLDef.LLD_SpecialSectionAttrBlock.FontWeight
         IF szFontWeight != ""
            szWriteBuffer = szWriteBuffer + " font-weight=^" + szFontWeight + "^"
         END

         szLineHeight = mSPLDef.LLD_SpecialSectionAttrBlock.TextLineHeight
         IF szLineHeight != ""
            szWriteBuffer = szWriteBuffer + " line-height=^" + szLineHeight + "^"
         END

         szLetterSpace = mSPLDef.LLD_SpecialSectionAttrBlock.TextLetterSpace
         IF szLetterSpace != ""
            szWriteBuffer = szWriteBuffer + " letter-spacing=^" + szLetterSpace + "px^"
         END

         szMBP = mSPLDef.LLD_SpecialSectionAttrBlock.Margin
         IF szMBP = ""
            szTopMBP = mSPLDef.LLD_SpecialSectionAttrBlock.MarginTop
            IF szTopMBP != ""
               szWriteBuffer = szWriteBuffer + " margin-top=^" + szTopMBP + "in^"
            END
            szBottomMBP = mSPLDef.LLD_SpecialSectionAttrBlock.MarginBottom
            IF szBottomMBP != ""
               szWriteBuffer = szWriteBuffer + " margin-bottom=^" + szBottomMBP + "in^"
            END
            szLeftMBP = mSPLDef.LLD_SpecialSectionAttrBlock.MarginLeft
            IF szLeftMBP != ""
               szWriteBuffer = szWriteBuffer + " margin-left=^" + szLeftMBP + "in^"
            END
            szRightMBP = mSPLDef.LLD_SpecialSectionAttrBlock.MarginRight
            IF szRightMBP != ""
               szWriteBuffer = szWriteBuffer + " margin-right=^" + szRightMBP + "in^"
            END
         ELSE
            szWriteBuffer = szWriteBuffer + " margin=^" + szMBP + "in^"
         END

         szMBP = mSPLDef.LLD_SpecialSectionAttrBlock.Border
         IF szMBP = ""
            szTopMBP = mSPLDef.LLD_SpecialSectionAttrBlock.BorderTop
            IF szTopMBP != ""
               szWriteBuffer = szWriteBuffer + " border-top=^" + szTopMBP + "in^"
            END
            szBottomMBP = mSPLDef.LLD_SpecialSectionAttrBlock.BorderBottom
            IF szBottomMBP != ""
               szWriteBuffer = szWriteBuffer + " border-bottom=^" + szBottomMBP + "in^"
            END
            szLeftMBP = mSPLDef.LLD_SpecialSectionAttrBlock.BorderLeft
            IF szLeftMBP != ""
               szWriteBuffer = szWriteBuffer + " border-left=^" + szLeftMBP + "in^"
            END
            szRightMBP = mSPLDef.LLD_SpecialSectionAttrBlock.BorderRight
            IF szRightMBP != ""
               szWriteBuffer = szWriteBuffer + " border-right=^" + szRightMBP + "in^"
            END
         ELSE
            szWriteBuffer = szWriteBuffer + " border=^" + szMBP + "in^"
         END

         szMBP = mSPLDef.LLD_SpecialSectionAttrBlock.Padding
         IF szMBP = ""
            szTopMBP = mSPLDef.LLD_SpecialSectionAttrBlock.PaddingTop
            IF szTopMBP != ""
               szWriteBuffer = szWriteBuffer + " padding-top=^" + szTopMBP + "in^"
            END
            szBottomMBP = mSPLDef.LLD_SpecialSectionAttrBlock.PaddingBottom
            IF szBottomMBP != ""
               szWriteBuffer = szWriteBuffer + " padding-bottom=^" + szBottomMBP + "in^"
            END
            szLeftMBP = mSPLDef.LLD_SpecialSectionAttrBlock.PaddingLeft
            IF szLeftMBP != ""
               szWriteBuffer = szWriteBuffer + " padding-left=^" + szLeftMBP + "in^"
            END
            szRightMBP = mSPLDef.LLD_SpecialSectionAttrBlock.PaddingRight
            IF szRightMBP != ""
               szWriteBuffer = szWriteBuffer + " padding-right=^" + szRightMBP + "in^"
            END
         ELSE
            szWriteBuffer = szWriteBuffer + " padding=^" + szMBP + "in^"
         END

         IF szRightMBP != ""
            szWriteBuffer = szWriteBuffer + " padding-right=^" + szRightMBP + "in^"
         END

         szTextAlign = mSPLDef.LLD_SpecialSectionAttrBlock.TextAlign
         IF szTextAlign != ""
            szWriteBuffer = szWriteBuffer + " text-align=^" + szTextAlign + "^"
         END
      ELSE
         // If the block has a Bottom Margin, use it for each block below.
         szBottomMBP = mSPLDef.LLD_Block.MarginBottom
         IF szBottomMBP != ""
            szWriteBuffer = szWriteBuffer + " margin-bottom=^" + szBottomMBP + "in^"
         END
      END
   ELSE
      // If the block has a Bottom Margin, use it for each block below.
      szBottomMBP = mSPLDef.LLD_Block.MarginBottom
      IF szBottomMBP != ""
         szWriteBuffer = szWriteBuffer + " margin-bottom=^" + szBottomMBP + "in^"
      END
   END

   // Close the Block.
   szWriteBuffer = szWriteBuffer + ">"

END

/////////////////////////////////////////////////////////////////////////////
//
//  OPERATION: GeneratePDF_DFU_Statement
//  Directions For Use (Category) / Storage and Disposal / General / Marketing
//
/////////////////////////////////////////////////////////////////////////////
LOCAL OPERATION
GeneratePDF_DFU_Section( VIEW mSPLDef    BASED ON LOD mSPLDef,
                         VIEW mSPLDefPDF BASED ON LOD mSPLDef,
                         INTEGER lFile,
                         STRING ( 50 ) szSectionType,
                         STRING ( 32 ) szSPLD_SectionName,
                         STRING ( 32 ) szStatementName,
                         STRING ( 32 ) szUsageTypeEntity,
                         STRING ( 32 ) szLoopingEntity,
                         STRING ( 50 ) szPassedBlanks,
                         STRING ( 32000 ) szWriteBuffer )

   VIEW mSPLDefPanelLevel BASED ON LOD mSPLDef
   VIEW mSPLDefContinue   BASED ON LOD mSPLDef
   STRING ( 32000 )  szStatementText
   STRING ( 32000 )  szTemporaryText
   STRING ( 256 )    szStatementTitle
   STRING ( 256 )    szTemporaryTitle
   STRING ( 50 )     szSectionTitle
   STRING ( 50 )     szSectionName
// STRING ( 50 )     szSectionType
   STRING ( 32 )     szSeparatorCharacters
   STRING ( 32 )     szNumberedText
   STRING ( 32 )     szLineHeight
   STRING ( 32 )     szStatementLeading
   STRING ( 2 )      szSectionTitlePosition
   STRING ( 2 )      szStatementTitlePosition
   STRING ( 2 )      szStatementFormat
   STRING ( 1 )      szFoundFirstNumberedEntryFlag
   STRING ( 50 )     szLeadingBlanks
   STRING ( 3 )      szDisplaySectionSuffix
   STRING ( 50 )     szDisplaySectionName
   STRING ( 50 )     szDisplayStatementName
   STRING ( 1 )      szContinuationFlag
   STRING ( 1 )      szBlockContinuationType
   STRING ( 1 )      szConvertToCapsFlag
   INTEGER           lCnt
   SHORT             nRC

   STRING ( 512 ) szDebugMsg

   // Generate PDF for a "Directions of Use" or "Storage and Disposal" or "General" or "Marketing" Statement.

   szLeadingBlanks = szPassedBlanks + "   "

   // We need to decide where the Statement Format type is being specified. It was stored in the TemplateSection.StatementFormat
   // attribute, but the TemplateSection entity is being eliminated. Maybe it should just go with the Block.
   // The same is true for szSeparatorCharacters = mSPLDef.SPLD_TemplateSection.UsageSeparatorCharacters
   szStatementFormat     = "SP"
   szSeparatorCharacters = ", "

   // If this is block for a Marketing Section, we need to position on the corresponding Market Section by Name.
   // Otherwise, we are positioned on the correct Section already.
   // We also need to initialize the XML for the Marketing Section.
// szSectionType = mSPLDefPDF.LLD_Block.LLD_SectionType ... now passed in (dks 2017.01.30)
   IF szSectionType = "Marketing"
      szSectionName = mSPLDefPDF.LLD_Block.Name
      SetCursorFirstEntityByString( mSPLDef, szSPLD_SectionName, "Name", szSectionName, "" )
   // TraceLineS( "Processing Marketing section name: ", szSectionName )
   ELSE
   // TraceLineS( "Processing section type: ", szSectionType )
   END

   // Increment Display Section Suffix and Initialize DisplaySection entry.
   mSPLDef.SubregPhysicalLabelDef.wLastDisplaySuffixCount = mSPLDef.SubregPhysicalLabelDef.wLastDisplaySuffixCount + 1
   szDisplaySectionSuffix = mSPLDef.SubregPhysicalLabelDef.wLastDisplaySuffixCount
   szDisplaySectionName = "DisplaySection" + szDisplaySectionSuffix
   CREATE ENTITY mSPLDef.DisplaySection
   mSPLDef.DisplaySection.Type = szSPLD_SectionName
   mSPLDef.DisplaySection.XML_SectionName = szDisplaySectionName

   szSectionTitlePosition = mSPLDefPDF.LLD_Block.TitlePosition
   IF szSectionTitlePosition = ""
      szSectionTitlePosition = "SL"    // Default will put the Title on a separate line.
   END

   // Format Section Title, if there is a Title.   *** We need to something different with Section Title.
   GetStringFromAttribute( szSectionTitle, mSPLDef, szSPLD_SectionName, "Title" )
   IF szSectionTitle != ""
      szWriteBuffer = szLeadingBlanks + "<fo:block "
      AddFormatToSpecialText( mSPLDefPDF, szSectionType, "Title", szWriteBuffer )
      WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

      szWriteBuffer = szLeadingBlanks + "      <xsl:apply-templates select=^SubregPhysicalLabelDef/" + szDisplaySectionName + "/Title^/>"
      WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

      szWriteBuffer = szLeadingBlanks + "</fo:block>"
      WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )
   END

   // Format each Statement, including Title, if requested.
   // Get Title option from the LLD_SpecialSectionAttrBlock entity for Title option.
   szStatementTitlePosition = "SL"
   szConvertToCapsFlag = ""
   SET CURSOR FIRST mSPLDefPDF.LLD_SpecialSectionAttribute WHERE mSPLDefPDF.LLD_SpecialSectionAttribute.Name = "Title"
   IF RESULT >= zCURSOR_SET
      szStatementTitlePosition = mSPLDefPDF.LLD_SpecialSectionAttrBlock.TitlePosition
      IF szStatementTitlePosition = ""
         szStatementTitlePosition = "SL"
      END
      szConvertToCapsFlag = mSPLDefPDF.LLD_SpecialSectionAttrBlock.CapitalizeTitleTextFlag
   END

   
   nRC = SetCursorFirstEntity( mSPLDef, szStatementName, "" )
   LOOP WHILE nRC >= zCURSOR_SET

      // Get Continuation Flag used in logic below.
      GetStringFromAttribute( szContinuationFlag, mSPLDef, szStatementName, "ContinuationBreakFlag" )

      // Create the Display Statement entry, unless this Statement is a full continuation on next page.
      IF szContinuationFlag = "" OR szContinuationFlag = "M"
         mSPLDef.SubregPhysicalLabelDef.wLastDisplaySuffixCount = mSPLDef.SubregPhysicalLabelDef.wLastDisplaySuffixCount + 1
         szDisplaySectionSuffix = mSPLDef.SubregPhysicalLabelDef.wLastDisplaySuffixCount
         szDisplayStatementName = "DisplayStatement" + szDisplaySectionSuffix
         CREATE ENTITY mSPLDef.DisplayStatement
         mSPLDef.DisplayStatement.XML_StatementName = szDisplayStatementName
      END

      IF szContinuationFlag = "M"     // M indicates this Statement is to be broken up into two pieces on separate panels.
         // If this statement is to be split for continuation, get text from ContinuationLeadingText.
         GetStringFromAttribute( szStatementText, mSPLDef, szStatementName, "ContinuationLeadingText" )
      ELSE
         // It's not a continuation, so get all of the Text for the Statement.
         GetStringFromAttribute( szStatementText, mSPLDef, szStatementName, "Text" )
      END
      GetStringFromAttribute( szStatementTitle, mSPLDef, szStatementName, "Title" )

      // Convert Title to upper-case, if requested.
      IF szConvertToCapsFlag = "Y"
         szTemporaryTitle = szStatementTitle
         zToUpper( szTemporaryTitle, szStatementTitle )
      END

      // Combine Title in text if specified.
      IF szStatementTitle != "" AND szStatementTitlePosition = "CF"
         // Title is combined with Text.
         szTemporaryText = szStatementText
         szStatementText = szStatementTitle + " " + szTemporaryText
      ELSE
         // Format Title, if it exists and is requested.
         IF szStatementTitle != "" AND szStatementTitlePosition = "SL"
            szWriteBuffer = szLeadingBlanks + "   <fo:block "
            AddFormatToSpecialText( mSPLDefPDF, szSectionType, "Title", szWriteBuffer )
            WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

            //szWriteBuffer = szLeadingBlanks + "      " + szStatementTitle
            szWriteBuffer = szLeadingBlanks + "      <xsl:apply-templates select=^SubregPhysicalLabelDef/"
                                            + szDisplaySectionName + "/" + szDisplayStatementName + "/Title^/>"
            WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

            szWriteBuffer = szLeadingBlanks + "   </fo:block>"
            WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

            mSPLDef.DisplayStatement.Title = szStatementTitle
         END
      END

      // Process any mapping data for the following key words inserted in any text.
      //    {{Usage}}
      //    {{Claim}}
      //    {{Surface}}
      //    {{Location}}  {{Area Of Use}}
      //    {{Application Type}}
      //    {{Product Name}}
      //    {{Master Product}}
      //    {{Primary Registrant}}
      //    {{Subregistrant}}
      //
      IF szUsageTypeEntity != ""
         // Storage and Disposal has no keyword mapping.
         InsertKeywordsIntoString( mSPLDef, szStatementText, szUsageTypeEntity, szLoopingEntity, szSeparatorCharacters )
         SetAttributeFromString( mSPLDef, szStatementName, "wkDisplayText", szStatementText )
      END

      // If Statement is flagged as Continuation, process as:
      // If the Statement has Continuation Text, format the regular text here, and set up the Continuation subobject for continuation
      // on the next Panel for all remaining Statement entities.
      // If the Statement does NOT have Continuation Text, format this and all remaining Statement entities on next Panel.

      IF szContinuationFlag = ""

         // Process regular Statement Text.

         szWriteBuffer = szLeadingBlanks + "<fo:block "
         AddFormatToSpecialText( mSPLDefPDF, szSectionType, "Text", szWriteBuffer )
         WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

         //szWriteBuffer = szLeadingBlanks + "      " + szStatementText
         szWriteBuffer = szLeadingBlanks + "   <xsl:apply-templates select=^SubregPhysicalLabelDef/"
                                            + szDisplaySectionName + "/" + szDisplayStatementName + "/Text^/>"
         WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

         szWriteBuffer = szLeadingBlanks + "</fo:block>"
         WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

         mSPLDef.DisplayStatement.Text = szStatementText

      ELSE

         // Process Continuation.
         // Skip if a prior statement was a continuation.
         IF szBlockContinuationType = ""

            // If this is a partial text continuation, format the first part of the text on the current Block.
            IF szContinuationFlag = "M"
               szWriteBuffer = szLeadingBlanks + "   <fo:block "
               AddFormatToSpecialText( mSPLDefPDF, szSectionType, "Text", szWriteBuffer )
               WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

               szWriteBuffer = szLeadingBlanks + "      <xsl:apply-templates select=^SubregPhysicalLabelDef/"
                                               + szDisplaySectionName + "/" + szDisplayStatementName + "/Text^/>"
               WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

               szWriteBuffer = szLeadingBlanks + "   </fo:block>"
               WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

               mSPLDef.DisplayStatement.Text = szStatementText
            END

            // When this code was written there was a core error where an entity created under view mSPLDefPanelLevel couldn't
            // be seen under view mSPLDefPDF. Thus the reason for the somewhat awkward code below where mSPLDefPanelLevel
            // is the same view as mSPLDefPDF for the case where the continuation is to the next Block.

            szDebugMsg = mSPLDefPDF.LLD_Block.ID
            szDebugMsg = szDebugMsg + "   Tag: " + mSPLDefPDF.LLD_Block.Tag
            szDebugMsg = szDebugMsg + "   Name: " + mSPLDefPDF.LLD_Block.Name
            szDebugMsg = szDebugMsg + "   Title: " + mSPLDefPDF.LLD_Block.BlockTitle
            szDebugMsg = szDebugMsg + "   Section Type: " + mSPLDefPDF.LLD_Block.LLD_SectionType
            szDebugMsg = szDebugMsg + "   Continuation: " + mSPLDefPDF.LLD_Block.ContinuationBlockFlag
            TraceLineS( "Checking Continuation from Block ID: ",  szDebugMsg )


            // First look to see if the next Block is a Continuation Block and set flag.
            CreateViewFromView( mSPLDefContinue, mSPLDefPDF )
            SET CURSOR NEXT mSPLDefContinue.LLD_Block WHERE mSPLDefContinue.LLD_Block.ContinuationBlockFlag = "Y"
            IF RESULT >= zCURSOR_SET
               szDebugMsg = mSPLDefPDF.LLD_Block.ID
               szDebugMsg = szDebugMsg + "   Tag: " + mSPLDefContinue.LLD_Block.Tag
               szDebugMsg = szDebugMsg + "   Name: " + mSPLDefContinue.LLD_Block.Name
               szDebugMsg = szDebugMsg + "   Title: " + mSPLDefContinue.LLD_Block.BlockTitle
               szDebugMsg = szDebugMsg + "   Section Type: " + mSPLDefContinue.LLD_Block.LLD_SectionType
               szDebugMsg = szDebugMsg + "   Continuation: " + mSPLDefContinue.LLD_Block.ContinuationBlockFlag
               TraceLineS( "Checking Continuation To Block ID: ",  szDebugMsg )

            // IF mSPLDefPDF.LLD_Block.ContinuationBlockFlag = "Y"
                  szBlockContinuationType = "B"
            // ELSE
               // szBlockContinuationType = "P"
               // SET CURSOR PREVIOUS mSPLDefPDF.LLD_Block     // We need to undo the set cursor next above.
            // END
            ELSE
               szBlockContinuationType = "P"
            // SET CURSOR PREVIOUS mSPLDefPDF.LLD_Block     // We need to undo the set cursor next above.
            END
            DropView( mSPLDefContinue )

            // Create Panel view that will hold Continuation statements and position on next Panel, if this
            // is a Panel continuation, rather than a Block continuation.
    // DonC deleted the following commented lines because of a JOE error where the ContinuationStatement created
    // under mSPLDefPanelLevel didn't show under mSPLDef.
    // Also, we won't have to check continuing to a new Panel because we'll include the continue block.
    //        CreateViewFromView( mSPLDefPanelLevel, mSPLDef )
    //        NAME VIEW mSPLDefPanelLevel "mSPLDefPanelLevel"
    //        IF szBlockContinuationType = "P"
    //           SET CURSOR NEXT mSPLDefPanelLevel.LLD_Panel
    //        END
            // Remove any existing Continuation Statements.
    //        FOR EACH mSPLDefPanelLevel.ContinuationStatement
    //           DELETE ENTITY mSPLDefPanelLevel.ContinuationStatement NONE
    //        END

            IF szBlockContinuationType = "B"

               // Block continuation

               IF szContinuationFlag = "M"
                  // Continuation is in two pieces, so next text is ContinuationText.
                  GetStringFromAttribute( szTemporaryText, mSPLDef, szStatementName, "ContinuationText" )
                  CREATE ENTITY mSPLDef.ContinuationStatement
                  mSPLDef.ContinuationStatement.Text = szTemporaryText
               ELSE
                  // Initialize Continuation entry with Regular Text.
                  CREATE ENTITY mSPLDef.ContinuationStatement
                  IF szStatementTitle != "" AND szStatementTitlePosition = "SL"
                     mSPLDef.ContinuationStatement.Title = szStatementTitle
                  END
                  mSPLDef.ContinuationStatement.Text = szStatementText
               END
//TraceLineS( "##########********** Create Continue 1: ", mSPLDefPDF.LLD_Block.LLD_SectionType )

               // Add any remaining Statement entries to continuation, that will be generated for the next Panel.
               // This will position us on the last Statement under the Section so that we will exit this operation without generating
               // another Statement for this Panel.
               nRC = SetCursorNextEntity( mSPLDef, szStatementName, "" )
               LOOP WHILE nRC >= zCURSOR_SET
                  GetStringFromAttribute( szStatementText, mSPLDef, szStatementName, "Text" )
                  GetStringFromAttribute( szStatementTitle, mSPLDef, szStatementName, "Title" )
                  CREATE ENTITY mSPLDef.ContinuationStatement
                  IF szStatementTitle != "" AND szStatementTitlePosition = "SL"
                     mSPLDef.ContinuationStatement.Title = szStatementTitle
                  END
                  mSPLDef.ContinuationStatement.Text = szStatementText

                  nRC = SetCursorNextEntity( mSPLDef, szStatementName, "" )
               END
//     // Debug Code
//     SET CURSOR FIRST mSPLDef.ContinuationStatement
//     IF RESULT >= zCURSOR_SET
//        TraceLineS( "##########********** Continue Text: ", mSPLDef.ContinuationStatement.Text )
//     ELSE
//        IssueError( mSPLDef,0,0, "stop" )
//     END
//     TraceLineS( "##########********** szStatementName: ", szStatementName )
              // SET CURSOR PREVIOUS mSPLDefPDF.LLD_Block     // We need to undo the set cursor next above.
            ELSE

               // Panel continuation

               /*
               IF szContinuationFlag = "M"
                  // Continuation is in two pieces, so next text is ContinuationText.
                  GetStringFromAttribute( szTemporaryText, mSPLDef, szStatementName, "ContinuationText" )
                  CREATE ENTITY mSPLDefPanelLevel.ContinuationStatement
                  mSPLDefPanelLevel.ContinuationStatement.Text = szTemporaryText
               ELSE
                  // Initialize Continuation entry with Regular Text.
                  CREATE ENTITY mSPLDefPanelLevel.ContinuationStatement
                  IF szStatementTitle != "" AND szStatementTitlePosition = "SL"
                     mSPLDefPanelLevel.ContinuationStatement.Title = szStatementTitle
                  END
                  mSPLDefPanelLevel.ContinuationStatement.Text = szStatementText
               END
               */

               // Copy BlockSpecialAttributeBlock entries.
               // I decided not to do the following but use the formatting characteristics specified on the Continuation Block.
               /*
               FOR EACH mSPLDefPanelLevel.LLD_SpecialSectionAttribute
                  DELETE ENTITY mSPLDefPanelLevel.LLD_SpecialSectionAttribute NONE
               END
               FOR EACH mSPLDefPDF.LLD_SpecialSectionAttribute
                  CREATE ENTITY mSPLDefPanelLevel.LLD_SpecialSectionAttribute
                  mSPLDefPanelLevel.LLD_SpecialSectionAttribute.Name = mSPLDefPDF.LLD_SpecialSectionAttribute.Name
                  CREATE ENTITY mSPLDefPanelLevel.LLD_SpecialSectionAttrBlock
                  SetMatchingAttributesByName( mSPLDefPanelLevel, "LLD_SpecialSectionAttrBlock", mSPLDefPDF, "LLD_SpecialSectionAttrBlock", zSET_NULL )
               END
               */

               // Add any remaining Statement entries to continuation, that will be generated for the next Panel.
               // This will position us on the last Statement under the Section so that we will exit this operation without generating
               // another Statement for this Panel.
               /*
               nRC = SetCursorNextEntity( mSPLDef, szStatementName, "" )
               LOOP WHILE nRC >= zCURSOR_SET
                  GetStringFromAttribute( szStatementText, mSPLDef, szStatementName, "Text" )
                  GetStringFromAttribute( szStatementTitle, mSPLDef, szStatementName, "Title" )
                  CREATE ENTITY mSPLDefPanelLevel.ContinuationStatement
                  IF szStatementTitle != "" AND szStatementTitlePosition = "SL"
                     mSPLDefPanelLevel.ContinuationStatement.Title = szStatementTitle
                  END
                  mSPLDefPanelLevel.ContinuationStatement.Text = szStatementText

                  nRC = SetCursorNextEntity( mSPLDef, szStatementName, "" )
               END

               // Since this is a Panel continuation, add the Continuation verbage to the current Panel.
               szWriteBuffer = szLeadingBlanks + "   <fo:block margin-top=^.05in^>"
               WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

               szWriteBuffer = szLeadingBlanks + "      " + mSPLDef.SPLD_LLD.ContinuationPreviousPageText
               WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

               szWriteBuffer = szLeadingBlanks + "   </fo:block>"
               WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )
               */
            END

         // DropView( mSPLDefPanelLevel )
         END

      END

      nRC = SetCursorNextEntity( mSPLDef, szStatementName, "" )
   END

END

/////////////////////////////////////////////////////////////////////////////
//
//  OPERATION: GeneratePDF_DFU
//  Directions For Use (Category) / Storage and Disposal / General / Marketing
//
/////////////////////////////////////////////////////////////////////////////
TRANSFORMATION OPERATION
GeneratePDF_DFU( VIEW mSPLDef    BASED ON LOD mSPLDef,
                 VIEW mSPLDefPDF BASED ON LOD mSPLDef,
                 INTEGER lFile,
                 STRING ( 50 ) szSectionType,
                 STRING ( 32 ) szSPLD_SectionName,
                 STRING ( 32 ) szStatementName,
                 STRING ( 32 ) szUsageTypeEntity,
                 STRING ( 32 ) szLoopingEntity,
                 STRING ( 50 ) szPassedBlanks,
                 STRING ( 32000 ) szWriteBuffer )

   SHORT  nRC

   IF szStatementName = "SPLD_DirectionsForUseSection"
      nRC = SetCursorFirstEntity( mSPLDef, "SPLD_DirectionsForUseCategory", "" )
      LOOP WHILE nRC >= zCURSOR_SET
         GeneratePDF_DFU_Section( mSPLDef, mSPLDefPDF, lFile, szSectionType, szSPLD_SectionName, szStatementName,
                                  szUsageTypeEntity, szLoopingEntity, szPassedBlanks, szWriteBuffer )
         nRC = SetCursorFirstEntity( mSPLDef, "SPLD_DirectionsForUseCategory", "" )
      END
   ELSE
      GeneratePDF_DFU_Section( mSPLDef, mSPLDefPDF, lFile, szSectionType, szSPLD_SectionName, szStatementName,
                               szUsageTypeEntity, szLoopingEntity, szPassedBlanks, szWriteBuffer )
   END

END

/////////////////////////////////////////////////////////////////////////////
//
//  OPERATION: GeneratePDF_ClmList
//
/////////////////////////////////////////////////////////////////////////////
TRANSFORMATION OPERATION
GeneratePDF_ClmList( VIEW mSPLDef    BASED ON LOD mSPLDef,
                     VIEW mSPLDefPDF BASED ON LOD mSPLDef,
                     INTEGER lFile,
                     STRING ( 50 )    szSectionType,
                     STRING ( 256 )   szPassedBlanks,
                     STRING ( 32000 ) szWriteBuffer,
                     INTEGER NumberColumns )

   VIEW mSPLDef2 BASED ON LOD mSPLDef
   STRING ( 32000 )  szStatementText
   STRING ( 32000 )  szTemporaryText
   STRING ( 50 )     szLeadingBlanks
   STRING ( 50 )     szBreakName1
   STRING ( 50 )     szBreakName2
   STRING ( 32 )     szMarginRight
   STRING ( 32 )     szMarginLeft
   STRING ( 100 )    szSectionTitle
   STRING ( 100 )    szStatementTitle
   STRING ( 32 )     szTitleFormat
   STRING ( 50 )     szSectionName
   STRING ( 32 )     szColumnTop
   STRING ( 100 )    szCombinedName
   STRING ( 100 )    szFootnoteText
   STRING ( 3 )      szFootnoteNumber
   SHORT             nRC
   INTEGER           CurrentColumnNumber
   INTEGER           ItemCount
   INTEGER           FootnoteCount
   INTEGER           Column1Count
   INTEGER           Column2Count
   INTEGER           ColumnTotal
   DECIMAL           ContainingBlockWidth
   DECIMAL           ColumnWidth
   DECIMAL           ColumnHeight
   DECIMAL           OriginalTopMargin

   // Generate PDF for a "Directory of Use" or "Marketing" Section.

   szLeadingBlanks = szPassedBlanks + "   "

   // Column List of Claim Usage Statements
   // The dependent Claim Usage statements are to be listed in 2 or 3 columns, after any regular Statements
   // and organized by Claims Classifications.

   // Position on the correct Marketing Section.
   SET CURSOR FIRST mSPLDef.SPLD_MarketingSection WHERE mSPLDef.SPLD_MarketingSection.Name = mSPLDefPDF.LLD_Block.Name
   IF RESULT < zCURSOR_SET
      IssueError( mSPLDef,0,0, "No match on MarketingSection for Column" )
   END

   // Build the list of unique footnotes.
   FOR EACH mSPLDef.SPLD_UsageFootnote
      EXCLUDE mSPLDef.SPLD_UsageFootnote NONE
   END
   ItemCount = 0
   FOR EACH mSPLDef.SPLD_MarketingStatement
      FOR EACH mSPLDef.SPLD_MarketingUsageOrdering WITHIN mSPLDef.SPLD_MarketingSection
         IF mSPLDef.SPLD_MarketingUsage.UsageType = "C"
            ItemCount = ItemCount + 1
            SET CURSOR FIRST mSPLDef.SPLD_Usage
                       WHERE mSPLDef.SPLD_Usage.ID = mSPLDef.SPLD_MarketingUsage.ID
            IF RESULT >=zCURSOR_SET
               IF mSPLDef.SPLD_UsageFootnoteUsed EXISTS
                  SET CURSOR FIRST mSPLDef.SPLD_UsageFootnote
                             WHERE mSPLDef.SPLD_UsageFootnote.ID = mSPLDef.SPLD_UsageFootnoteUsed.ID
                  IF RESULT < zCURSOR_SET
                     CREATE ENTITY mSPLDef.SPLD_UsageFootnote
                     mSPLDef.SPLD_UsageFootnote.ID   = mSPLDef.SPLD_UsageFootnoteUsed.ID
                     mSPLDef.SPLD_UsageFootnote.Text = mSPLDef.SPLD_UsageFootnoteUsed.Text
                  END
               END
            END
         END
      END
   END
   IF ItemCount = 0
      // There are no Claims entries, so give error and exit.
      MessageSend( mSPLDef, "", "Generate Label",
                   "The Marketing Section for Column list has no Claim entries.",
                   zMSGQ_OBJECT_CONSTRAINT_ERROR, 0 )
      RETURN 2
   END

   FootnoteCount = 0
   FOR EACH mSPLDef.SPLD_UsageFootnote
      FootnoteCount = FootnoteCount + 1
      ItemCount     = ItemCount + 1  // Also add to total item count.
      mSPLDef.SPLD_UsageFootnote.wFootNoteRelativeNumber = FootnoteCount
   END

   // Set the work attribute with combination Usage Name and Footnote designator.
   FOR EACH mSPLDef.SPLD_MarketingStatement
      FOR EACH mSPLDef.SPLD_MarketingUsageOrdering WITHIN mSPLDef.SPLD_MarketingSection
         szCombinedName = mSPLDef.SPLD_MarketingUsage.Name
         SET CURSOR FIRST mSPLDef.SPLD_Usage
                    WHERE mSPLDef.SPLD_Usage.ID = mSPLDef.SPLD_MarketingUsage.ID
         IF RESULT >=zCURSOR_SET
            IF mSPLDef.SPLD_UsageFootnoteUsed EXISTS
               SET CURSOR FIRST mSPLDef.SPLD_UsageFootnote
                          WHERE mSPLDef.SPLD_UsageFootnote.ID = mSPLDef.SPLD_UsageFootnoteUsed.ID
               szFootnoteNumber = mSPLDef.SPLD_UsageFootnote.Symbol
               IF szFootnoteNumber = ""
                  szFootnoteNumber = mSPLDef.SPLD_UsageFootnote.wFootNoteRelativeNumber
               END
               szCombinedName = szCombinedName + "<sup> " + szFootnoteNumber + "</sup>"
            END
            mSPLDef.SPLD_MarketingUsage.wNameWithFootnoteDesignator = szCombinedName
         END
      END
   END

   // Build the two or three columns subobjects from the SPLD_MarketingUsageOrdering entities.
   // If specific breaks have been specified, break there. If not, put the same number of entries in each column.
   IF mSPLDefPDF.LLD_Block.UsageColumn1BreakName = ""
      Column1Count = ItemCount / NumberColumns
      ColumnTotal = Column1Count * NumberColumns
      IF ColumnTotal < ItemCount
         // Since column aren't going to be equal, add one to first and second columns.
         Column1Count = Column1Count + 1
      END
      Column2Count = Column1Count * 2    // The last count of the second column is twice the last count of the first.
      ItemCount = 0
      FOR EACH mSPLDef.SPLD_MarketingUsageOrdering WITHIN mSPLDef.SPLD_MarketingSection
         IF mSPLDef.SPLD_MarketingUsage.UsageType = "C"
            ItemCount = ItemCount + 1
            IF ItemCount <= Column1Count
               CREATE ENTITY mSPLDef.DisplayUsageColumn1
               mSPLDef.DisplayUsageColumn1.Name = mSPLDef.SPLD_MarketingUsage.wNameWithFootnoteDesignator
            ELSE
               IF ItemCount > Column1Count AND ItemCount <= Column2Count
                  CREATE ENTITY mSPLDef.DisplayUsageColumn2
                  mSPLDef.DisplayUsageColumn2.Name = mSPLDef.SPLD_MarketingUsage.wNameWithFootnoteDesignator
               ELSE
                  CREATE ENTITY mSPLDef.DisplayUsageColumn3
                  mSPLDef.DisplayUsageColumn3.Name = mSPLDef.SPLD_MarketingUsage.wNameWithFootnoteDesignator
               END
            END
         END
      END

      // Set CurrentColumnNumber for any footnote processing below.
      IF ItemCount <= Column1Count
         CurrentColumnNumber = 1
      ELSE
         IF ItemCount <= Column2Count
            CurrentColumnNumber = 2
         ELSE
            CurrentColumnNumber = 3
         END
      END

   ELSE
      // Specific Breaks have been specified.
      szBreakName1 = mSPLDefPDF.LLD_Block.UsageColumn1BreakName
      szBreakName2 = mSPLDefPDF.LLD_Block.UsageColumn2BreakName
      CurrentColumnNumber = 1
      FOR EACH mSPLDef.SPLD_MarketingUsageOrdering WITHIN mSPLDef.SPLD_MarketingSection
         IF mSPLDef.SPLD_MarketingUsage.UsageType = "C"
            IF mSPLDef.SPLD_MarketingUsage.Name = szBreakName1
               CurrentColumnNumber = 2
            ELSE
               IF mSPLDef.SPLD_MarketingUsage.Name = szBreakName2
                  CurrentColumnNumber = 3
               END
            END
            IF CurrentColumnNumber = 1
               CREATE ENTITY mSPLDef.DisplayUsageColumn1
               mSPLDef.DisplayUsageColumn1.Name = mSPLDef.SPLD_MarketingUsage.wNameWithFootnoteDesignator
            ELSE
               IF CurrentColumnNumber = 2
                  CREATE ENTITY mSPLDef.DisplayUsageColumn2
                  mSPLDef.DisplayUsageColumn2.Name = mSPLDef.SPLD_MarketingUsage.wNameWithFootnoteDesignator
               ELSE
                  CREATE ENTITY mSPLDef.DisplayUsageColumn3
                  mSPLDef.DisplayUsageColumn3.Name = mSPLDef.SPLD_MarketingUsage.wNameWithFootnoteDesignator
               END
            END
         END
      END
   END

   // Add any Footnote entries to the last Column.
   FOR EACH mSPLDef.SPLD_UsageFootnote
      szFootnoteNumber = mSPLDef.SPLD_UsageFootnote.Symbol
      IF szFootnoteNumber = ""
         szFootnoteNumber = mSPLDef.SPLD_UsageFootnote.wFootNoteRelativeNumber
      END
      szFootnoteText = "<sup> " + szFootnoteNumber + "</sup>" + mSPLDef.SPLD_UsageFootnote.Text
      IF CurrentColumnNumber = 1
         CREATE ENTITY mSPLDef.DisplayUsageColumn1
         mSPLDef.DisplayUsageColumn1.Name = szFootnoteText
      ELSE
         IF CurrentColumnNumber = 2
            CREATE ENTITY mSPLDef.DisplayUsageColumn2
            mSPLDef.DisplayUsageColumn2.Name = szFootnoteText
         ELSE
            CREATE ENTITY mSPLDef.DisplayUsageColumn3
            mSPLDef.DisplayUsageColumn3.Name = szFootnoteText
         END
      END
   END

   // Build the two or three Blocks listing the entries in each of the three work subobjects.
   // If there is a Column definition entry, we will get the Top, Width and LeftMargin values from there.
   // If not, the width of each Block (column) will be 1/2 or 1/3 of the width of the source Block, minus the left margin,
   // which is from the main block.
   // We will create a temporary Block, initialized from the source Block, with the modified values for
   // each of the three columns.

   ACTIVATE mSPLDef2 EMPTY
   NAME VIEW mSPLDef2 "mSPLDef2"
   CREATE ENTITY mSPLDef2.SubregPhysicalLabelDef
   CREATE ENTITY mSPLDef2.SPLD_LLD
   CREATE ENTITY mSPLDef2.LLD_Page
   CREATE ENTITY mSPLDef2.LLD_Panel
   CREATE ENTITY mSPLDef2.LLD_Block
   SetMatchingAttributesByName( mSPLDef2, "LLD_Block", mSPLDefPDF, "LLD_Block", zSET_ALL )

   ContainingBlockWidth = mSPLDefPDF.LLD_Block.Width
   ColumnWidth = ContainingBlockWidth / NumberColumns
   mSPLDef2.LLD_Block.Width = ColumnWidth
   mSPLDef2.LLD_Block.Left  = 0

   // The top will be whatever is in the Block, plus any top margin for the Column List LLD_SpecialSectionAttribute.

   SET CURSOR FIRST mSPLDefPDF.LLD_SpecialSectionAttribute WHERE mSPLDefPDF.LLD_SpecialSectionAttribute.Name = "Column List"
   IF RESULT >= zCURSOR_SET
      mSPLDef2.LLD_Block.Top = mSPLDefPDF.LLD_SpecialSectionAttrBlock.MarginTop
      szColumnTop = mSPLDef2.LLD_Block.Top
      // The MarginTop of LLD_SpecialSectionAttrBlock is used only for specifying the BlockContainer holding the individual entries
      // within a column, but not for each entry within a column. Thus we need set two different values, the Original TopMargin
      // value for the BlockContainer and null for each row. Because we're modifying the TopMargin value in the object, we need
      // to reset it in the end.
      // We will create mSPLDef2 for generating the BlockContainer for the column and use mSPLDefPDF for each row.
      OriginalTopMargin = mSPLDefPDF.LLD_SpecialSectionAttrBlock.MarginTop
      szMarginLeft       = mSPLDefPDF.LLD_SpecialSectionAttrBlock.MarginLeft
      szMarginRight      = mSPLDefPDF.LLD_SpecialSectionAttrBlock.MarginRight

      // Create a Block LLD_SpecialSectionAttribute entry containing the characteristics of the Column List entry, except for dropping
      // the top margin.
      CREATE ENTITY mSPLDef2.LLD_SpecialSectionAttribute
      mSPLDef2.LLD_SpecialSectionAttribute.Name = "Block"
      CREATE ENTITY mSPLDef2.LLD_SpecialSectionAttrBlock
      SetMatchingAttributesByName( mSPLDef2, "LLD_SpecialSectionAttrBlock", mSPLDefPDF, "LLD_SpecialSectionAttrBlock", zSET_ALL )
      mSPLDefPDF.LLD_SpecialSectionAttrBlock.MarginTop = ""     // Now set MarginTop for each row.
   ELSE

      mSPLDef2.LLD_Block.Top = mSPLDef2.LLD_Block.Top
      szMarginLeft  = ".01"
      szMarginRight = ".01"
   END
   ColumnHeight = mSPLDefPDF.LLD_Block.Height - mSPLDef2.LLD_Block.Top
   mSPLDef2.LLD_Block.Height = ColumnHeight

   szSectionName = mSPLDef.DisplaySection.XML_SectionName

   // Generate column 1 Block.
   FormatBlockContainer( mSPLDef2, mSPLDef, lFile, szLeadingBlanks, szWriteBuffer, szColumnTop )

   szWriteBuffer = szLeadingBlanks + "   <xsl:for-each select=^SubregPhysicalLabelDef/" + szSectionName + "/DisplayUsageColumn1^>"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

   szWriteBuffer = szLeadingBlanks + "      <fo:block "
   AddFormatToSpecialText( mSPLDefPDF, szSectionType, "Column List", szWriteBuffer )
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

   szWriteBuffer = szLeadingBlanks + "         <xsl:apply-templates select=^Name^/>"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )
   szWriteBuffer = szLeadingBlanks + "      </fo:block>"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

   szWriteBuffer = szLeadingBlanks + "   </xsl:for-each>"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

   szWriteBuffer = szLeadingBlanks + "</fo:block-container>"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

   // Generate column 2 Block.
   mSPLDef2.LLD_Block.Left = mSPLDef2.LLD_Block.Left + ColumnWidth
   FormatBlockContainer( mSPLDef2, mSPLDef, lFile, szLeadingBlanks, szWriteBuffer, szColumnTop )

   szWriteBuffer = szLeadingBlanks + "   <xsl:for-each select=^SubregPhysicalLabelDef/" + szSectionName + "/DisplayUsageColumn2^>"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

   szWriteBuffer = szLeadingBlanks + "      <fo:block "
   AddFormatToSpecialText( mSPLDefPDF, szSectionType, "Column List", szWriteBuffer )
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

   szWriteBuffer = szLeadingBlanks + "         <xsl:apply-templates select=^Name^/>"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )
   szWriteBuffer = szLeadingBlanks + "      </fo:block>"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

   szWriteBuffer = szLeadingBlanks + "   </xsl:for-each>"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

   szWriteBuffer = szLeadingBlanks + "</fo:block-container>"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

   // Generate column 3 Block.
   IF NumberColumns = 3
      mSPLDef2.LLD_Block.Left = mSPLDef2.LLD_Block.Left + ColumnWidth
      FormatBlockContainer( mSPLDef2, mSPLDef, lFile, szLeadingBlanks, szWriteBuffer, szColumnTop )

      szWriteBuffer = szLeadingBlanks + "   <xsl:for-each select=^SubregPhysicalLabelDef/" + szSectionName + "/DisplayUsageColumn3^>"
      WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

      szWriteBuffer = szLeadingBlanks + "      <fo:block "
      AddFormatToSpecialText( mSPLDefPDF, szSectionType, "Column List", szWriteBuffer )
      WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

      szWriteBuffer = szLeadingBlanks + "         <xsl:apply-templates select=^Name^/>"
      WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )
      szWriteBuffer = szLeadingBlanks + "      </fo:block>"
      WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

      szWriteBuffer = szLeadingBlanks + "   </xsl:for-each>"
      WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

      szWriteBuffer = szLeadingBlanks + "</fo:block-container>"
      WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )
   END

   //DELETE ENTITY mSPLDef2.LLD_Block NONE
   DropObjectInstance( mSPLDef2 )

   // Build the work object containing each Claim under the appropriate Classification.
   // Type: C - Claim;  S - Surface;  T - Application Type;  U - Location (Area of Use).
   // ClaimsClassification: Bacteria; Protozoa; Viruses; Fungi.
   // First delete any existing entries.
   FOR EACH mSPLDef.SPLDI_ClaimsClassification
      DELETE ENTITY mSPLDef.SPLDI_ClaimsClassification NONE
   END
   FOR EACH mSPLDef.SPLD_MarketingUsageOrdering WITHIN mSPLDef.SPLD_MarketingSection
             WHERE mSPLDef.SPLD_MarketingUsage.UsageType = "C" // just looking for Type=Claim
      SET CURSOR FIRST mSPLDef.SPLDI_ClaimsClassification
                 WHERE mSPLDef.SPLDI_ClaimsClassification.ClaimsClassification = mSPLDef.SPLD_MarketingUsage.ClaimsClassification
      IF RESULT < zCURSOR_SET
         // Did not find the entity of the proper ClaimsClassification, so create one.
         CREATE ENTITY mSPLDef.SPLDI_ClaimsClassification
         mSPLDef.SPLDI_ClaimsClassification.ClaimsClassification = mSPLDef.SPLD_MarketingUsage.ClaimsClassification
         INCLUDE mSPLDef.SPLDI_ClaimsUsage FROM mSPLDef.SPLD_MarketingUsage
         IF RESULT < 0
            TraceLineS( "GeneratePDF_ClmList Include SPLDI_ClaimsUsage FROM SPLD_MarketingUsage", " ======== CAN'T HAPPEN ===========================" )
            DisplayEntityInstance( mSPLDef, "SPLDI_ClaimsUsage" )
            DisplayEntityInstance( mSPLDef, "SPLD_MarketingUsage" )
            IssueError( mSPLDef, 0, 0, "Include Error" )
         END
      ELSE
         // Check to see if the SPLD_MarketingUsage has already been included under the current ClaimsClassification.
         SET CURSOR FIRST mSPLDef.SPLDI_ClaimsUsage WHERE mSPLDef.SPLDI_ClaimsUsage.ID = mSPLDef.SPLD_MarketingUsage.ID
         IF RESULT < zCURSOR_SET
            // Not already included so set cursor to the last included to include the entity at the end.
            SET CURSOR LAST mSPLDef.SPLDI_ClaimsUsage
            INCLUDE mSPLDef.SPLDI_ClaimsUsage FROM mSPLDef.SPLD_MarketingUsage
            IF RESULT < 0
               TraceLineS( "GeneratePDF_ClmList Include SPLDI_ClaimsUsage FROM SPLD_MarketingUsage", " =========== CAN'T HAPPEN EITHER ========================" )
               DisplayEntityInstance( mSPLDef, "SPLDI_ClaimsUsage" )
               DisplayEntityInstance( mSPLDef, "SPLD_MarketingUsage" )
               IssueError( mSPLDef, 0, 0, "Include Error" )
            END
         ELSE
            TraceLineS( "GeneratePDF_ClmList Include SPLDI_ClaimsUsage FROM SPLD_MarketingUsage", " ====== ALREADY INCLUDED ... COULD HAPPEN =============================" )
         // DisplayEntityInstance( mSPLDef, "SPLDI_ClaimsUsage" )
            DisplayEntityInstance( mSPLDef, "SPLD_MarketingUsage" )
         END
      END
   END

   // Reset LLD_SpecialSectionAttrBlock.MarginTop back to its original value.
   mSPLDefPDF.LLD_SpecialSectionAttrBlock.MarginTop = OriginalTopMargin

END

/////////////////////////////////////////////////////////////////////////////
//
//  OPERATION: GeneratePDF_Ingred
//  Generate Active Ingredients
//
/////////////////////////////////////////////////////////////////////////////
TRANSFORMATION OPERATION
GeneratePDF_Ingred( VIEW mSPLDef    BASED ON LOD mSPLDef,
                    VIEW mSPLDefPDF BASED ON LOD mSPLDef,
                    INTEGER lFile,
                    STRING ( 50 )    szSectionType,
                    STRING ( 50 )    szPassedBlanks,
                    STRING ( 32000 ) szWriteBuffer )

   STRING ( 50 )    szLeadingBlanks
   STRING ( 512 )   szIngredientsText
   STRING ( 256 )   szPeriodFiller
   STRING ( 16 )    szPercent
   // Generate XSL Statements for a "Active Ingredients" Section.

   szLeadingBlanks = szPassedBlanks + "   "
   SET CURSOR FIRST mSPLDef.SPLD_IngredientsSection
   szWriteBuffer = szLeadingBlanks + "<!-- Ingredients Section using Leader -->"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )
   //FormatBlockContainer( mSPLDef, mSPLDef, lFile, szLeadingBlanks, szWriteBuffer, "" )

   // Ingredients Title
   szWriteBuffer = szLeadingBlanks + "<fo:block "
   AddFormatToSpecialText( mSPLDefPDF, szSectionType, "Ingredients Title", szWriteBuffer )
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

   szWriteBuffer = szLeadingBlanks + "   <xsl:apply-templates select=^SubregPhysicalLabelDef/SPLD_IngredientsSection/ActiveTitle^/>"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

   szWriteBuffer = szLeadingBlanks + "</fo:block>"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

   // Ingredients Percent
   // Use XSL Leader for formatting.
   szWriteBuffer = szLeadingBlanks + "<xsl:for-each select=^SubregPhysicalLabelDef/SPLD_IngredientsSection/SPLD_IngredientsStatement^>"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

   szWriteBuffer = szLeadingBlanks + "   <fo:block text-align-last=^justify^ "
   AddFormatToSpecialText( mSPLDefPDF, szSectionType, "Ingredients Items", szWriteBuffer )
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

   szWriteBuffer = szLeadingBlanks + "      <xsl:apply-templates select=^ChemicalName^/>"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

   szWriteBuffer = szLeadingBlanks + "      <fo:leader leader-pattern=^dots^ />"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

   szWriteBuffer = szLeadingBlanks + "      <xsl:apply-templates select=^Percent^/>%"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

   szWriteBuffer = szLeadingBlanks + "   </fo:block>"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

   szWriteBuffer = szLeadingBlanks + "</xsl:for-each>"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

   // Inert Percent
   IF mSPLDef.SPLD_IngredientsSection.GeneralInactivePercent > 0
      szWriteBuffer = szLeadingBlanks + "<fo:block text-align-last=^justify^ "
      AddFormatToSpecialText( mSPLDefPDF, szSectionType, "Ingredients Inert", szWriteBuffer )
      WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

      szWriteBuffer = szLeadingBlanks + "   <xsl:apply-templates select=^SubregPhysicalLabelDef/SPLD_IngredientsSection/InertTitle^/>"
      WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

      szWriteBuffer = szLeadingBlanks + "   <fo:leader leader-pattern=^dots^ />"
      WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

      szWriteBuffer = szLeadingBlanks + "   <xsl:apply-templates select=^SubregPhysicalLabelDef/SPLD_IngredientsSection/GeneralInactivePercent^/>%"
      WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

      szWriteBuffer = szLeadingBlanks + "</fo:block>"
      WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )
   END

   // Total
   szWriteBuffer = szLeadingBlanks + "<fo:block text-align-last=^justify^ "
   AddFormatToSpecialText( mSPLDefPDF, szSectionType, "Ingredients Total", szWriteBuffer )
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

   szWriteBuffer = szLeadingBlanks + "   TOTAL"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

   szWriteBuffer = szLeadingBlanks + "   <fo:leader leader-pattern=^dots^ />100%"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

   szWriteBuffer = szLeadingBlanks + "</fo:block>"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

   // Close opening Block.
   //szWriteBuffer = szLeadingBlanks + "</fo:block-container>"
   //WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

END

/////////////////////////////////////////////////////////////////////////////
//
//  OPERATION: GeneratePDF_Content
//  Generate Net Contents
//
/////////////////////////////////////////////////////////////////////////////
TRANSFORMATION OPERATION
GeneratePDF_Content( VIEW mSPLDef    BASED ON LOD mSPLDef,
                     VIEW mSPLDefPDF BASED ON LOD mSPLDef,
                     INTEGER lFile,
                     STRING ( 50 )    szSectionType,
                     STRING ( 50 )    szPassedBlanks,
                     STRING ( 32000 ) szWriteBuffer )

   STRING ( 50 )    szLeadingBlanks
   STRING ( 512 )   szNetContentsText
   // Generate PDF for "NetContents".

   szLeadingBlanks = szPassedBlanks + "   "

   //szNetContentsText = mSPLDef.SPLD_TemplateSection.TitleOverride
   IF szNetContentsText = ""
      szNetContentsText = "Net Contents: One Gallon (3.784 litres)"
   END

   szWriteBuffer = szLeadingBlanks + "<fo:block "
   AddFormatToSpecialText( mSPLDefPDF, szSectionType, "Text", szWriteBuffer )
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

   szWriteBuffer = szLeadingBlanks + "   " + szNetContentsText
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

   szWriteBuffer = szLeadingBlanks + "</fo:block>"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

END

/////////////////////////////////////////////////////////////////////////////
//
/////////////////////////////////////////////////////////////////////////////
TRANSFORMATION OPERATION
GeneratePDF_EPA_Reg( VIEW mSPLDef    BASED ON LOD mSPLDef,
                     VIEW mSPLDefPDF BASED ON LOD mSPLDef,
                     INTEGER lFile,
                     STRING ( 50 )    szSectionType,
                     STRING ( 50 )    szPassedBlanks,
                     STRING ( 32000 ) szWriteBuffer )

   STRING ( 50 )    szLeadingBlanks
   STRING ( 32000 ) szStatementText
   STRING ( 32 )    szEPA_RegNbr
   STRING ( 32 )    szEPA_EstNbr
   // Generate PDF for EPA Reg. No. and EPA Est. No..

   szLeadingBlanks = szPassedBlanks + "   "
   SET CURSOR FIRST mSPLDef.SPLD_HumanHazardSection
   szEPA_RegNbr = mSPLDef.SubregProduct.EPA_RegistrationNumber
   IF szEPA_RegNbr = ""
      szEPA_RegNbr = "*****"
   END
   szEPA_EstNbr = mSPLDef.SubregProduct.EPA_EstablishmentNumber
   IF szEPA_EstNbr = ""
      szEPA_EstNbr = "*****"
   END
   szStatementText = "EPA Reg. No. " + szEPA_RegNbr + "   EPA Est. No. " + szEPA_EstNbr

   szWriteBuffer = szLeadingBlanks + "<fo:block "
   AddFormatToSpecialText( mSPLDefPDF, szSectionType, "Text", szWriteBuffer )
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

   szWriteBuffer = szLeadingBlanks + "   " + szStatementText
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

   szWriteBuffer = szLeadingBlanks + "</fo:block>"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

END

/////////////////////////////////////////////////////////////////////////////
//
//  OPERATION: GeneratePDF_Hazards
//  Generate Hazards
//
/////////////////////////////////////////////////////////////////////////////
TRANSFORMATION OPERATION
GeneratePDF_Hazards( VIEW mSPLDef    BASED ON LOD mSPLDef,
                     VIEW mSPLDefPDF BASED ON LOD mSPLDef,
                     INTEGER lFile,
                     STRING ( 50 )    szSectionType,
                     STRING ( 50 )    szPassedBlanks,
                     STRING ( 32000 ) szWriteBuffer )

   STRING ( 50 )   szLeadingBlanks
   STRING ( 90 )   szChildHazardWarning
   STRING ( 90 )   szEPA_SignalWord
   STRING ( 1000 ) szStatementText

   // Generate PDF for each Hazards key word.

   szLeadingBlanks = szPassedBlanks + "   "
   SET CURSOR FIRST mSPLDef.SPLD_HumanHazardSection
   GetStringFromAttributeByContext( szChildHazardWarning, mSPLDef, "SPLD_HumanHazardSection", "EPA_ChildHazardWarning", "", 90 )
   szEPA_SignalWord     = mSPLDef.SPLD_HumanHazardSection.EPA_SignalWord
   szStatementText      = mSPLDef.SPLD_HumanHazardSection.dSelectedStatement

   // Child Hazard Warning
   szWriteBuffer = szLeadingBlanks + "<fo:block "
   AddFormatToSpecialText( mSPLDefPDF, szSectionType, "Hazards Warning", szWriteBuffer )
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

   szWriteBuffer = szLeadingBlanks + "   " + szChildHazardWarning
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

   szWriteBuffer = szLeadingBlanks + "</fo:block>"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

   // EPA Signal Word
   szWriteBuffer = szLeadingBlanks + "<fo:block "
   AddFormatToSpecialText( mSPLDefPDF, szSectionType, "Hazards Signal Word", szWriteBuffer )
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

   szWriteBuffer = szLeadingBlanks + "   " + szEPA_SignalWord
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

   szWriteBuffer = szLeadingBlanks + "</fo:block>"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

   // Precautionary Statement
   szWriteBuffer = szLeadingBlanks + "<fo:block "
   AddFormatToSpecialText( mSPLDefPDF, szSectionType, "Hazards Precautionary", szWriteBuffer )
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

   szWriteBuffer = szLeadingBlanks + "   " + szStatementText
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

   szWriteBuffer = szLeadingBlanks + "</fo:block>"
   WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )

END

/////////////////////////////////////////////////////////////////////////////
//
//  OPERATION: GeneratePDF_General
//  Generate  Precautionary, Environmental/Physical Hazard or First Aid Statements
//
/////////////////////////////////////////////////////////////////////////////
TRANSFORMATION OPERATION
GeneratePDF_General( VIEW mSPLDef    BASED ON LOD mSPLDef,
                     VIEW mSPLDefPDF BASED ON LOD mSPLDef,
                     INTEGER lFile,
                     STRING ( 50 )    szPassedBlanks,
                     STRING ( 32000 ) szWriteBuffer )

   STRING ( 50 )     szLeadingBlanks
   STRING ( 32000 )  szStatementText
   STRING ( 256 )    szCombinedTitle
   STRING ( 32 )     szLineHeight
   STRING ( 32 )     szStatementLeading

   // Generate PDF for a "General" Section, which can be Precautionary, Environmental/Physical Hazard or First Aid.

   szLeadingBlanks = szPassedBlanks + "   "
   szLineHeight = ""
   /*szStatementLeading = mSPLDef.SPLD_TemplateSection.dStatementLeading
   IF szStatementLeading != ""
      szLineHeight = "line-height:" + szStatementLeading +";"
   ELSE
      szStatementLeading = mSPLDef.SPLD_TemplatePanel.dStatementLeadingDefault
      IF szStatementLeading != ""
         szLineHeight = "line-height:" + szStatementLeading +";"
      END
   END
   //SET CURSOR FIRST mSPLDef.SPLD_GeneralSection WHERE mSPLDef.SPLD_GeneralSection.ID = mSPLDef.SPLDT_GeneralSection.ID
// DisplayEntityInstance( mSPLDef, "SPLD_GeneralSection" )
   GeneratePDF_Title( mSPLDef, lFile, "SPLD_GeneralSection", szCombinedTitle, szWriteBuffer )
   FOR EACH mSPLDef.SPLD_GeneralStatement
      szStatementText = szCombinedTitle + mSPLDef.SPLD_GeneralStatement.Text
      szWriteBuffer = szCombinedTitle + szStatementText
      IF szLineHeight != ""
         AddHTML_TagAttribute( mSPLDef, szWriteBuffer, 32000, "p", "style", szLineHeight, zQUOTES, 2 )
      ELSE
         AddHTML_TagAttribute( mSPLDef, szWriteBuffer, 32000, "p", "", "", "", 0 )
      END
      WL_QC( mSPLDef, lFile, szWriteBuffer, "^", 0 )
      szCombinedTitle = ""    // null out any combined Title that was to be included on the first statement
   END*/

END

/////////////////////////////////////////////////////////////////////////////
//
//  OPERATION: GeneratePDF_StorDisp
//  Generate Storage and Disposal Statements
//
/////////////////////////////////////////////////////////////////////////////
TRANSFORMATION OPERATION
GeneratePDF_StorDisp( VIEW mSPLDef    BASED ON LOD mSPLDef,
                      VIEW mSPLDefPDF BASED ON LOD mSPLDef,
                      INTEGER lFile,
                      STRING ( 32 )    szSectionType,
                      STRING ( 50 )    szPassedBlanks,
                      STRING ( 32000 ) szWriteBuffer )

   // Right now there appears to be no reason why the Storage and Disposal section can't reuse the same code
   // as the Directions For Use and Marketing sections.

END

/////////////////////////////////////////////////////////////////////////////
//
//  OPERATION: CopyDirsForUseStmts
//
/////////////////////////////////////////////////////////////////////////////
LOCAL OPERATION
CopyDirsForUseStmts( VIEW NewSPLD BASED ON LOD mSPLDef,
                     VIEW SrcSLC  BASED ON LOD mSubLC )

// SHORT nAllChanges
// SHORT nChanges
// SHORT nSubChanges
// SHORT nTemp

// nAllChanges = 0
   FOR EACH SrcSLC.S_DirectionsForUseStatement
//    nChanges = 0
//    nSubChanges = 0
      CREATE ENTITY NewSPLD.SPLD_DirectionsForUseStatement
      SetMatchingAttributesByName( NewSPLD, "SPLD_DirectionsForUseStatement",
                                   SrcSLC, "S_DirectionsForUseStatement", zSET_NULL )
      INCLUDE NewSPLD.S_DirectionsForUseStatement FROM SrcSLC.S_DirectionsForUseStatement

      FOR EACH SrcSLC.S_InsertTextKeywordDU
      // IF SrcSLC.S_InsertTextKeywordDU.Selected = "Y"
         // nChanges = nChanges + 1
            CREATE ENTITY NewSPLD.SPLD_InsertTextKeywordDU
            SetMatchingAttributesByName( NewSPLD, "SPLD_InsertTextKeywordDU", SrcSLC, "S_InsertTextKeywordDU", zSET_NULL )
            FOR EACH SrcSLC.S_InsertTextDU
            // IF SrcSLC.S_InsertTextDU.Selected = "Y"
                  CREATE ENTITY NewSPLD.SPLD_InsertTextDU
                  SetMatchingAttributesByName( NewSPLD, "SPLD_InsertTextDU", SrcSLC, "S_InsertTextDU", zSET_NULL )
            // END
            END
      // END
      END
      FOR EACH SrcSLC.S_DirectionsUsageOrdering
         SET CURSOR FIRST NewSPLD.SPLD_Usage WITHIN NewSPLD.SubregLabelContent
                    WHERE NewSPLD.SPLD_Usage.PrimarySLC_ID = SrcSLC.S_DirectionsUsage.ID
         IF RESULT >= zCURSOR_SET
            CREATE ENTITY NewSPLD.SPLD_DirectionsUsageOrdering
            NewSPLD.SPLD_DirectionsUsageOrdering.PrimarySLC_ID = SrcSLC.S_DirectionsUsageOrdering.ID
            INCLUDE NewSPLD.SPLD_DirectionsUsage FROM NewSPLD.SPLD_Usage
         END
      END
      IF SrcSLC.S_DirectionsForUseSubStatement EXISTS
         SetViewToSubobject( SrcSLC, "S_DirectionsForUseSubStatement" )
         SetViewToSubobject( NewSPLD, "SPLD_DirectionsForUseSubStmt" )
         CopyDirsForUseStmts( NewSPLD, SrcSLC )
      // nTemp = CopyDirsForUseStmts( NewSPLD, SrcSLC )
      // nSubChanges = nSubChanges + nTemp
         ResetViewFromSubobject( NewSPLD )
         ResetViewFromSubobject( SrcSLC )
      END
   // nChanges = nChanges + nSubChanges
   // IF nChanges = 0
   //    DELETE ENTITY NewSPLD.SPLD_DirectionsForUseStatement LAST
   // ELSE
   //    nAllChanges = nAllChanges + nChanges
   // END
   END
// RETURN nAllChanges
END

/////////////////////////////////////////////////////////////////////////////
//
//  OPERATION: CopyDirsForUseSection
//
/////////////////////////////////////////////////////////////////////////////
LOCAL OPERATION
CopyDirsForUseSection( VIEW NewSPLD BASED ON LOD mSPLDef,
                       VIEW SrcSLC  BASED ON LOD mSubLC )

   CREATE ENTITY NewSPLD.SPLD_DirectionsForUseSection
   SetMatchingAttributesByName( NewSPLD, "SPLD_DirectionsForUseSection", SrcSLC, "S_DirectionsForUseSection", zSET_NULL )
   INCLUDE NewSPLD.S_DirectionsForUseSection FROM SrcSLC.S_DirectionsForUseSection
   FOR EACH SrcSLC.S_InsertTextKeywordSectionDU
   // IF SrcSLC.S_InsertTextKeywordSectionDU.Selected = "Y"
         CREATE ENTITY NewSPLD.SPLD_InsertTextKeywordSectionDU
         SetMatchingAttributesByName( NewSPLD, "SPLD_InsertTextKeywordSectionDU", SrcSLC, "S_InsertTextKeywordSectionDU", zSET_NULL )
         FOR EACH SrcSLC.S_InsertTextSectionDU
         // IF SrcSLC.S_InsertTextSectionDU.Selected = "Y"
               CREATE ENTITY NewSPLD.SPLD_InsertTextSectionDU
               SetMatchingAttributesByName( NewSPLD, "SPLD_InsertTextSectionDU", SrcSLC, "S_InsertTextSectionDU", zSET_NULL )
         // END
         END
   // END
   END
   CopyDirsForUseStmts( NewSPLD, SrcSLC )
   RETURN 0
END

/////////////////////////////////////////////////////////////////////////////
//
//  OPERATION: CopyStorDispStmts
//
/////////////////////////////////////////////////////////////////////////////
LOCAL OPERATION
CopyStorDispStmts( VIEW NewSPLD BASED ON LOD mSPLDef,
                   VIEW SrcSLC  BASED ON LOD mSubLC )
   SHORT nAllChanges
   SHORT nChanges
   SHORT nSubChanges
   SHORT nTemp

   nAllChanges = 0
   FOR EACH SrcSLC.S_StorageDisposalStatement
      nChanges = 0
      nSubChanges = 0
      CREATE ENTITY NewSPLD.SPLD_StorageDisposalStatement
      SetMatchingAttributesByName( NewSPLD, "SPLD_StorageDisposalStatement", SrcSLC, "S_StorageDisposalStatement", zSET_NULL )
      INCLUDE NewSPLD.S_StorageDisposalStatement FROM SrcSLC.S_StorageDisposalStatement
      TraceLineS( "Copy Storage/Disposal Statement: ", SrcSLC.S_StorageDisposalStatement.dSD_TitleText )
      FOR EACH SrcSLC.S_InsertTextKeywordSD
         IF SrcSLC.S_InsertTextKeywordSD.Selected = "Y"
            nChanges = nChanges + 1
            CREATE ENTITY NewSPLD.SPLD_InsertTextKeywordSD
            SetMatchingAttributesByName( NewSPLD, "SPLD_InsertTextKeywordSD", SrcSLC, "S_InsertTextKeywordSD", zSET_NULL )
            FOR EACH SrcSLC.S_InsertTextSD
            // IF SrcSLC.S_InsertTextSD.Selected = "Y"
                  CREATE ENTITY NewSPLD.SPLD_InsertTextSD
                  SetMatchingAttributesByName( NewSPLD, "SPLD_InsertTextSD", SrcSLC, "S_InsertTextSD", zSET_NULL )
            // END
            END
         END
      END
      IF SrcSLC.S_StorageDisposalSubStatement EXISTS
         TraceLineS( "Copy Storage/Disposal SubStatement: ", SrcSLC.S_StorageDisposalSubStatement.dSD_SubTitleText )
         DisplayEntityInstance( SrcSLC, "S_StorageDisposalSubStatement" )
         SetViewToSubobject( SrcSLC, "S_StorageDisposalSubStatement" )
         SetViewToSubobject( NewSPLD, "SPLD_StorageDisposalSubStmt" )
         nTemp = CopyStorDispStmts( NewSPLD, SrcSLC )
         nSubChanges = nSubChanges + nTemp
         ResetViewFromSubobject( NewSPLD )
         ResetViewFromSubobject( SrcSLC )
      END
      nChanges = nChanges + nSubChanges
      IF nChanges = 0
         DELETE ENTITY NewSPLD.SPLD_StorageDisposalStatement LAST
      ELSE
         nAllChanges = nAllChanges + nChanges
      END
   END
   RETURN nAllChanges

END

/////////////////////////////////////////////////////////////////////////////
//
//  OPERATION: CopyUsagesRecursive
//
/////////////////////////////////////////////////////////////////////////////
LOCAL OPERATION
CopyUsagesRecursive( VIEW NewSPLD BASED ON LOD mSPLDef,
                     VIEW SrcSLC  BASED ON LOD mSubLC )

   STRING ( 256 ) szText
// SHORT nAllChanges
// SHORT nChanges
// SHORT nSubChanges
// SHORT nTemp

// nAllChanges = 0
   FOR EACH SrcSLC.S_Usage
   // nChanges = 0
   // nSubChanges = 0
      CREATE ENTITY NewSPLD.SPLD_Usage
      SetMatchingAttributesByName( NewSPLD, "SPLD_Usage", SrcSLC, "S_Usage", zSET_NULL )
      NewSPLD.SPLD_Usage.PrimarySLC_ID = SrcSLC.S_Usage.ID
      INCLUDE NewSPLD.S_Usage FROM SrcSLC.S_Usage
      FOR EACH SrcSLC.S_InsertTextKeywordUsage
      // IF SrcSLC.S_InsertTextKeywordUsage.Selected = "Y"
         // nChanges = nChanges + 1
            CREATE ENTITY NewSPLD.SPLD_InsertTextKeywordUsage
            SetMatchingAttributesByName( NewSPLD, "SPLD_InsertTextKeywordUsage", SrcSLC, "S_InsertTextKeywordUsage", zSET_NULL )
            FOR EACH SrcSLC.S_InsertTextUsage
            // IF SrcSLC.S_InsertTextUsage.Selected = "Y"
                  CREATE ENTITY NewSPLD.SPLD_InsertTextUsage
                  SetMatchingAttributesByName( NewSPLD, "SPLD_InsertTextUsage", SrcSLC, "S_InsertTextUsage", zSET_NULL )
            // END
            END
      // END
      END
      IF SrcSLC.S_UsageFootnoteUsed EXISTS
         szText = SrcSLC.S_UsageFootnoteUsed.Text
         SET CURSOR FIRST NewSPLD.SPLD_UsageFootnote WHERE NewSPLD.SPLD_UsageFootnote.Text = szText
         INCLUDE NewSPLD.SPLD_UsageFootnoteUsed FROM NewSPLD.SPLD_UsageFootnote
      END
      IF SrcSLC.S_SubUsage EXISTS
         SetViewToSubobject( SrcSLC, "S_SubUsage" )
         SetViewToSubobject( NewSPLD, "SPLD_SubUsage" )
         FOR EACH SrcSLC.S_Usage
            CopyUsagesRecursive( NewSPLD, SrcSLC )
         // nTemp = CopyUsagesRecursive( NewSPLD, SrcSLC )
         // nSubChanges = nSubChanges + nTemp
         END
         ResetViewFromSubobject( NewSPLD )
         ResetViewFromSubobject( SrcSLC )
      END
   // nChanges = nChanges + nSubChanges
   // IF nChanges = 0
   //    DELETE ENTITY NewSPLD.SPLD_Usage LAST
   // ELSE
   //    nAllChanges = nAllChanges + nChanges
   // END
   END
   
// return nAllChanges

END

/////////////////////////////////////////////////////////////////////////////
//
//  OPERATION: BuildSPLD_FromSLC
//
/////////////////////////////////////////////////////////////////////////////
TRANSFORMATION OPERATION
BuildSPLD_FromSLC( VIEW NewSPLD  BASED ON LOD mSPLDef,
                   VIEW SrcSLC   BASED ON LOD mSubLC )

   VIEW mSPLDef2 BASED ON LOD mSPLDef
   STRING ( 256 ) szName

   // Build a new SPLD from the selected Subregistrant Label Content entry.
// TraceLineS( "BuildSPLD_FromSLC SLC", "=====================>>>>>>>>" )
// DisplayObjectInstance( SrcSLC, "", "" )

   // Tie back to SLC, if necessary.
   IF NewSPLD.SubregLabelContent DOES NOT EXIST
      INCLUDE NewSPLD.SubregLabelContent FROM SrcSLC.SubregLabelContent
   END

   // Delete any current component entries.
   FOR EACH NewSPLD.SPLD_GeneralSection
      DELETE ENTITY NewSPLD.SPLD_GeneralSection NONE
   END
   FOR EACH NewSPLD.SPLD_IngredientsSection
      DELETE ENTITY NewSPLD.SPLD_IngredientsSection NONE
   END
   FOR EACH NewSPLD.SPLD_StorageDisposalSection
      DELETE ENTITY NewSPLD.SPLD_StorageDisposalSection NONE
   END
   FOR EACH NewSPLD.SPLD_DirectionsForUseSection
      DELETE ENTITY NewSPLD.SPLD_DirectionsForUseSection NONE
   END
   FOR EACH NewSPLD.SPLD_MarketingSection
      DELETE ENTITY NewSPLD.SPLD_MarketingSection NONE
   END
   FOR EACH NewSPLD.SPLD_HumanHazardSection
      DELETE ENTITY NewSPLD.SPLD_HumanHazardSection NONE
   END
   FOR EACH NewSPLD.SPLD_UsageType
      DELETE ENTITY NewSPLD.SPLD_UsageType NONE
   END

   // General Section ... Precautionary, First Aid, Other Hazard
   FOR EACH SrcSLC.S_GeneralSection
      CREATE ENTITY NewSPLD.SPLD_GeneralSection
      SetMatchingAttributesByName( NewSPLD, "SPLD_GeneralSection", SrcSLC, "S_GeneralSection", zSET_NULL )
      INCLUDE NewSPLD.S_GeneralSection FROM SrcSLC.S_GeneralSection
      FOR EACH SrcSLC.S_GeneralStatement
         CREATE ENTITY NewSPLD.SPLD_GeneralStatement
         SetMatchingAttributesByName( NewSPLD, "SPLD_GeneralStatement", SrcSLC, "S_GeneralStatement", zSET_NULL )
         INCLUDE NewSPLD.S_GeneralStatement FROM SrcSLC.S_GeneralStatement
         FOR EACH SrcSLC.S_InsertTextKeyword
            IF SrcSLC.S_InsertTextKeyword.Selected = "Y"
               CREATE ENTITY NewSPLD.SPLD_InsertTextKeyword
               SetMatchingAttributesByName( NewSPLD, "SPLD_InsertTextKeyword", SrcSLC, "S_InsertTextKeyword", zSET_NULL )
               FOR EACH SrcSLC.S_InsertText
                  IF SrcSLC.S_InsertText.Selected = "Y"
                     CREATE ENTITY NewSPLD.SPLD_InsertText
                     SetMatchingAttributesByName( NewSPLD, "SPLD_InsertText", SrcSLC, "S_InsertText", zSET_NULL )
                  END
               END
            END
         END
      END
      FOR EACH SrcSLC.S_GeneralSubSection
         CREATE ENTITY NewSPLD.SPLD_GeneralSubSection
         SetMatchingAttributesByName( NewSPLD, "SPLD_GeneralSubSection", SrcSLC, "S_GeneralSubSection", zSET_NULL )
         INCLUDE NewSPLD.S_GeneralSubSection FROM SrcSLC.S_GeneralSubSection
         FOR EACH SrcSLC.S_GeneralSubStatement
            CREATE ENTITY NewSPLD.SPLD_GeneralSubStatement
            SetMatchingAttributesByName( NewSPLD, "SPLD_GeneralSubStatement", SrcSLC, "S_GeneralSubStatement", zSET_NULL )
            INCLUDE NewSPLD.S_GeneralSubStatement FROM SrcSLC.S_GeneralSubStatement
            FOR EACH SrcSLC.S_InsertTextKeywordGeneral
               IF SrcSLC.S_InsertTextKeywordGeneral.Selected = "Y"
                  CREATE ENTITY NewSPLD.SPLD_InsertTextKeywordGeneral
                  SetMatchingAttributesByName( NewSPLD, "SPLD_InsertTextKeywordGeneral", SrcSLC, "S_InsertTextKeywordGeneral", zSET_NULL )
                  FOR EACH SrcSLC.S_InsertTextGeneral
                     IF SrcSLC.S_InsertTextGeneral.Selected = "Y"
                        CREATE ENTITY NewSPLD.SPLD_InsertTextGeneral
                        SetMatchingAttributesByName( NewSPLD, "SPLD_InsertTextGeneral", SrcSLC, "S_InsertTextGeneral", zSET_NULL )
                     END
                  END
               END
            END
         END
      END
   END

   // Footnotes
   FOR EACH SrcSLC.S_UsageFootnote
      CREATE ENTITY NewSPLD.SPLD_UsageFootnote
      SetMatchingAttributesByName( NewSPLD, "SPLD_UsageFootnote", SrcSLC, "S_UsageFootnote", zSET_NULL )
   END

   // Usages ... Claim, Surface, Application Type, Location 
   FOR EACH SrcSLC.S_UsageType
      CREATE ENTITY NewSPLD.SPLD_UsageType
      SetMatchingAttributesByName( NewSPLD, "SPLD_UsageType", SrcSLC, "S_UsageType", zSET_NULL )
      INCLUDE NewSPLD.S_UsageType FROM SrcSLC.S_UsageType
      CopyUsagesRecursive( NewSPLD, SrcSLC )
      FOR EACH SrcSLC.S_UsageGroup
         CREATE ENTITY NewSPLD.SPLD_UsageGroup
         SetMatchingAttributesByName( NewSPLD, "SPLD_UsageGroup", SrcSLC, "S_UsageGroup", zSET_NULL )
      END
   END

   // Ingredients Section
   FOR EACH SrcSLC.S_IngredientsSection
      CREATE ENTITY NewSPLD.SPLD_IngredientsSection
      SetMatchingAttributesByName( NewSPLD, "SPLD_IngredientsSection", SrcSLC, "S_IngredientsSection", zSET_NULL )
      INCLUDE NewSPLD.S_IngredientsSection FROM SrcSLC.S_IngredientsSection
      FOR EACH SrcSLC.S_IngredientsStatement
         CREATE ENTITY NewSPLD.SPLD_IngredientsStatement
         SetMatchingAttributesByName( NewSPLD, "SPLD_IngredientsStatement", SrcSLC, "S_IngredientsStatement", zSET_NULL )
         INCLUDE NewSPLD.S_IngredientsStatement FROM SrcSLC.S_IngredientsStatement
      END
   END

   // StorageDisposal Section
   FOR EACH SrcSLC.S_StorageDisposalSection
      IF SrcSLC.S_StorageDisposalSection.Selected = "Y"
         CREATE ENTITY NewSPLD.SPLD_StorageDisposalSection
         SetMatchingAttributesByName( NewSPLD, "SPLD_StorageDisposalSection", SrcSLC, "S_StorageDisposalSection", zSET_NULL )
         szName = SrcSLC.S_StorageDisposalSection.Name
         TraceLineS( "BuildSPLD Storage/Disposal Section SLC: ", szName )
         DisplayEntityInstance( SrcSLC, "S_StorageDisposalSection" )
         INCLUDE NewSPLD.S_StorageDisposalSection FROM SrcSLC.S_StorageDisposalSection
         CopyStorDispStmts( NewSPLD, SrcSLC )
         szName = NewSPLD.SPLD_StorageDisposalSection.Name
         TraceLineS( "BuildSPLD Storage/Disposal Section SPLD: ", szName )
         DisplayEntityInstance( NewSPLD, "SPLD_StorageDisposalSection" )
      END
   END

   // Tables
   FOR EACH SrcSLC.S_MetaTable
      CREATE ENTITY NewSPLD.SPLD_MetaTable
      SetMatchingAttributesByName( NewSPLD, "SPLD_MetaTable", SrcSLC, "S_MetaTable", zSET_NULL )
      FOR EACH SrcSLC.S_Rows
         CREATE ENTITY NewSPLD.SPLD_Rows
         SetMatchingAttributesByName( NewSPLD, "SPLD_Rows", SrcSLC, "S_Rows", zSET_NULL )
      END
   END

   // Dilutions
   FOR EACH SrcSLC.S_DilutionGroup
      CREATE ENTITY NewSPLD.SPLD_DilutionGroup
      SetMatchingAttributesByName( NewSPLD, "SPLD_DilutionGroup", SrcSLC, "S_DilutionGroup", zSET_NULL )
   // TraceLineS( "SPLD_FromSLC SPLD_DilutionGroup ", "=====================>>>>>>>>" )
   // DisplayEntityInstance( NewSPLD, "SPLD_DilutionGroup" )
   // NewSPLD.SPLD_DilutionGroup.PrimarySLC_ID = SrcSLC.S_DilutionGroup.ID
   // INCLUDE NewSPLD.SPLD_DilutionGroup FROM SrcSLC.M_DilutionGroup
      // Dilution Chart Entries
      FOR EACH SrcSLC.S_DilutionChartEntry
         CREATE ENTITY NewSPLD.SPLD_DilutionChartEntry
         SetMatchingAttributesByName( NewSPLD, "SPLD_DilutionChartEntry", SrcSLC, "S_DilutionChartEntry", zSET_NULL )
      // TraceLineS( "SPLD_FromSLC SPLD_DilutionChartEntry ", "=====================>>>>>>>>" )
      // DisplayEntityInstance( NewSPLD, "SPLD_DilutionChartEntry" )
      // NewSPLD.SPLD_DilutionChartEntry.PrimarySLC_ID = SrcSLC.SLC_DilutionChartEntry.ID
      END
      // Dilution Group Items
      FOR EACH SrcSLC.S_DilutionGroupItem
         CREATE ENTITY NewSPLD.SPLD_DilutionGroupItem
         SetMatchingAttributesByName( NewSPLD, "SPLD_DilutionGroupItem", SrcSLC, "S_DilutionGroupItem", zSET_NULL )
      // TraceLineS( "SPLD_FromMLC SPLD_DilutionGroupItem ", "=====================>>>>>>>>" )
      // DisplayEntityInstance( NewSPLD, "SPLD_DilutionGroupItem" )
      // NewSPLD.SPLD_DilutionGroupItem.PrimarySLC_ID = SrcSLC.SLC_DilutionGroupItem.ID
      END
   END

   // HumanHazard Section
   FOR EACH SrcSLC.S_HumanHazardSection
      CREATE ENTITY NewSPLD.SPLD_HumanHazardSection
      SetMatchingAttributesByName( NewSPLD, "SPLD_HumanHazardSection", SrcSLC, "S_HumanHazardSection", zSET_NULL )
      INCLUDE NewSPLD.S_HumanHazardSection FROM SrcSLC.S_HumanHazardSection
   END

   // Add any Directions For Use Sections that aren't driven by Usage entries.
   FOR EACH SrcSLC.S_DirectionsForUseCategory
      CREATE ENTITY NewSPLD.SPLD_DirectionsForUseCategory
      SetMatchingAttributesByName( NewSPLD, "SPLD_DirectionsForUseCategory", SrcSLC, "S_DirectionsForUseCategory", zSET_NULL )
      szName = SrcSLC.S_DirectionsForUseCategory.Name
      TraceLineS( "BuildSPLD DirectionsForUse Category SLC: ", szName )
      DisplayEntityInstance( SrcSLC, "S_DirectionsForUseCategory" )
      INCLUDE NewSPLD.S_DirectionsForUseCategory FROM SrcSLC.S_DirectionsForUseCategory
      FOR EACH SrcSLC.S_DirectionsForUseSection
         IF SrcSLC.S_ClaimsDrivingUsage DOES NOT EXIST
            // No Driving Usage entry exists, so always copy the section.
            CopyDirsForUseSection( NewSPLD, SrcSLC )
         END
      END
   END

   // Build Marketing Entries (without Usage entries).
   FOR EACH SrcSLC.S_MarketingSection
      CREATE ENTITY NewSPLD.SPLD_MarketingSection
      SetMatchingAttributesByName( NewSPLD, "SPLD_MarketingSection", SrcSLC, "S_MarketingSection", zSET_NULL )
      INCLUDE NewSPLD.S_MarketingSection FROM SrcSLC.S_MarketingSection
      FOR EACH SrcSLC.S_MarketingStatement
         CREATE ENTITY NewSPLD.SPLD_MarketingStatement
         SetMatchingAttributesByName( NewSPLD, "SPLD_MarketingStatement", SrcSLC, "S_MarketingStatement", zSET_NULL )
         INCLUDE NewSPLD.S_MarketingStatement FROM SrcSLC.S_MarketingStatement
         FOR EACH SrcSLC.S_InsertTextKeywordMarketing
            IF SrcSLC.S_InsertTextKeywordMarketing.Selected = "Y"
               CREATE ENTITY NewSPLD.SPLD_InsertTextKeywordMarketing
               SetMatchingAttributesByName( NewSPLD, "SPLD_InsertTextKeywordMarketing", SrcSLC, "S_InsertTextKeywordMarketing", zSET_NULL )
               FOR EACH SrcSLC.S_InsertTextMarketing
                  IF SrcSLC.S_InsertTextMarketing.Selected = "Y"
                     CREATE ENTITY NewSPLD.SPLD_InsertTextMarketing
                     SetMatchingAttributesByName( NewSPLD, "SPLD_InsertTextMarketing", SrcSLC, "S_InsertTextMarketing", zSET_NULL )
                  END
               END
            END
         END
      END
   END

   // Go to build Directions For Use and Marketing Usage entries.
   BuildUsageEntriesFrSLC( NewSPLD, SrcSLC )
// TraceLineS( "BuildSPLD_FromSLC NewSPLD", "=====================>>>>>>>>" )
// DisplayObjectInstance( NewSPLD, "", "" )

END

/////////////////////////////////////////////////////////////////////////////
//
//  OPERATION: RebuildSPLD_FromSLC
//
/////////////////////////////////////////////////////////////////////////////
TRANSFORMATION OPERATION
RebuildSPLD_FromSLC( VIEW NewSPLD BASED ON LOD mSPLDef,
                     VIEW SrcSLC  BASED ON LOD mSubLC )

   // DonC 1/11/206 - I don't think we are using this code.

   /*VIEW mSPLDef2 BASED ON LOD mSPLDef
   // Correct Directions and Marketing entries by rebuilding them.
   FOR EACH NewSPLD.SPLD_DirectionsForUseSection
      DELETE ENTITY NewSPLD.SPLD_DirectionsForUseSection NONE
   END
   FOR EACH NewSPLD.SPLD_MarketingSection
      DELETE ENTITY NewSPLD.SPLD_MarketingSection NONE
   END
   // Build Directions For Use Entries (without Usage entries).
   FOR EACH SrcSLC.S_DirectionsForUseSection
      CREATE ENTITY NewSPLD.SPLD_DirectionsForUseSection
      SetMatchingAttributesByName( NewSPLD, "SPLD_DirectionsForUseSection", SrcSLC, "S_DirectionsForUseSection", zSET_NULL )
      INCLUDE NewSPLD.S_DirectionsForUseSection FROM SrcSLC.S_DirectionsForUseSection
      FOR EACH SrcSLC.S_DirectionsForUseStatement
         CREATE ENTITY NewSPLD.SPLD_DirectionsForUseStatement
         SetMatchingAttributesByName( NewSPLD, "SPLD_DirectionsForUseStatement", SrcSLC, "S_DirectionsForUseStatement", zSET_NULL )
      END
   END
   // Build Marketing Entries (without Usage entries).
   FOR EACH SrcSLC.S_MarketingSection
      CREATE ENTITY NewSPLD.SPLD_MarketingSection
      SetMatchingAttributesByName( NewSPLD, "SPLD_MarketingSection", SrcSLC, "S_MarketingSection", zSET_NULL )
      INCLUDE NewSPLD.S_MarketingSection FROM SrcSLC.S_MarketingSection
      FOR EACH SrcSLC.S_MarketingStatement
         CREATE ENTITY NewSPLD.SPLD_MarketingStatement
         SetMatchingAttributesByName( NewSPLD, "SPLD_MarketingStatement", SrcSLC, "S_MarketingStatement", zSET_NULL )
      END
   END
   // Go to build Directions For Use and Marketing entries.
   BuildUsageEntriesFrSLC( NewSPLD, SrcSLC )*/

END

/////////////////////////////////////////////////////////////////////////////
//
//  OPERATION: BuildUsageEntriesFrSLC
//
/////////////////////////////////////////////////////////////////////////////
TRANSFORMATION OPERATION
BuildUsageEntriesFrSLC( VIEW mSPLDef   BASED ON LOD mSPLDef,
                        VIEW SrcSLC BASED ON LOD mSubLC )

   // Build the Usage, Directions For Use and Marketing subobject structures from the creating SrcSLC.

   // Delete current entries.
   FOR EACH mSPLDef.SPLD_UsageType
      DELETE ENTITY mSPLDef.SPLD_UsageType NONE
   END

   // Build Usage Entries (Surface, Application Type, Location (Area of Use), Organism Claim)
   FOR EACH SrcSLC.S_UsageType WITHIN SrcSLC.SubregLabelContent
      CREATE ENTITY mSPLDef.SPLD_UsageType
      SetMatchingAttributesByName( mSPLDef, "SPLD_UsageType", SrcSLC, "S_UsageType", zSET_NULL )
      FOR EACH SrcSLC.S_Usage
         CREATE ENTITY mSPLDef.SPLD_Usage
         SetMatchingAttributesByName( mSPLDef, "SPLD_Usage", SrcSLC, "S_Usage", zSET_NULL )
         INCLUDE mSPLDef.S_Usage FROM SrcSLC.S_Usage
      END
   END

   // Build Directions For Use Usage Entries.
   FOR EACH SrcSLC.S_DirectionsForUseSection
      SET CURSOR FIRST mSPLDef.S_DirectionsForUseSection WITHIN mSPLDef.SubregPhysicalLabelDef
                 WHERE mSPLDef.S_DirectionsForUseSection.ID = SrcSLC.S_DirectionsForUseSection.ID
      FOR EACH SrcSLC.S_DirectionsForUseStatement
         SET CURSOR FIRST mSPLDef.S_DirectionsForUseStatement WITHIN mSPLDef.SPLD_DirectionsForUseSection
                    WHERE mSPLDef.S_DirectionsForUseStatement.ID = SrcSLC.S_DirectionsForUseStatement.ID

         // Remove current entries.
         FOR EACH mSPLDef.SPLD_DirectionsUsageOrdering
            DELETE ENTITY mSPLDef.SPLD_DirectionsUsageOrdering NONE
         END

         // Add entries from SLC.
         FOR EACH SrcSLC.S_DirectionsUsageOrdering
            SET CURSOR FIRST mSPLDef.S_Usage WITHIN mSPLDef.SubregPhysicalLabelDef
                       WHERE mSPLDef.S_Usage.ID = SrcSLC.S_DirectionsUsage.ID
            IF RESULT >= zCURSOR_SET
               CREATE ENTITY mSPLDef.SPLD_DirectionsUsageOrdering
               INCLUDE mSPLDef.SPLD_DirectionsUsage FROM mSPLDef.SPLD_Usage
            END
         END
      END
   END

   // Build Marketing Entries.
   FOR EACH SrcSLC.S_MarketingSection
      SET CURSOR FIRST mSPLDef.S_MarketingSection WITHIN mSPLDef.SubregPhysicalLabelDef
                 WHERE mSPLDef.S_MarketingSection.ID = SrcSLC.S_MarketingSection.ID
      FOR EACH SrcSLC.S_MarketingStatement
         SET CURSOR FIRST mSPLDef.S_MarketingStatement WITHIN mSPLDef.SPLD_MarketingSection
                    WHERE mSPLDef.S_MarketingStatement.ID = SrcSLC.S_MarketingStatement.ID

         // Remove current entries.
         FOR EACH mSPLDef.SPLD_MarketingUsageOrdering
            DELETE ENTITY mSPLDef.SPLD_MarketingUsageOrdering NONE
         END

         // Add entries from SLC.
         FOR EACH SrcSLC.S_MarketingUsageOrdering
            SET CURSOR FIRST mSPLDef.S_Usage WITHIN mSPLDef.SubregPhysicalLabelDef
                       WHERE mSPLDef.S_Usage.ID = SrcSLC.S_MarketingUsage.ID
            IF RESULT >= zCURSOR_SET
               CREATE ENTITY mSPLDef.SPLD_MarketingUsageOrdering
               INCLUDE mSPLDef.SPLD_MarketingUsage FROM mSPLDef.SPLD_Usage
            END
         END
      END
   END

END

/////////////////////////////////////////////////////////////////////////////
//
//  OPERATION: BuildSPLD_FromSPLD
//
/////////////////////////////////////////////////////////////////////////////
TRANSFORMATION OPERATION
BuildSPLD_FromSPLD( VIEW NewSPLD    BASED ON LOD mSPLDef,
                    VIEW SourceSPLD BASED ON LOD mSPLDef,
                    VIEW ParentSLC  BASED ON LOD mSubLC )

   // Build a new SPLD from a previous SPLD.
   // Most of the component construction is the same as that in BuildSPLD_FromSLC. Only the LLD subobject is different.
   // So, reuse the BuildSPLD_FromSLC operation, then reuse the code for building an LLD section.

   BuildSPLD_FromSLC( NewSPLD, ParentSLC )

   // Copy the SPLD_LLD subobject.
   CREATE ENTITY NewSPLD.SPLD_LLD
   SetMatchingAttributesByName( NewSPLD, "S_HumanHazardSection", SourceSPLD, "S_HumanHazardSection", zSET_NULL )
   FOR EACH SourceSPLD.LLD_Page
      CREATE ENTITY NewSPLD.LLD_Page
      SetMatchingAttributesByName( NewSPLD, "LLD_Page", SourceSPLD, "LLD_Page", zSET_NULL )
      IF SourceSPLD.PageBackgroundColor EXISTS
         INCLUDE NewSPLD.PageBackgroundColor FROM SourceSPLD.PageBackgroundColor
      END
      FOR EACH SourceSPLD.LLD_Panel
         CREATE ENTITY NewSPLD.LLD_Panel
         SetMatchingAttributesByName( NewSPLD, "LLD_Panel", SourceSPLD, "LLD_Panel", zSET_NULL )
         IF SourceSPLD.PanelBackgroundColor EXISTS
            INCLUDE NewSPLD.PanelBackgroundColor FROM SourceSPLD.PanelBackgroundColor
         END
         IF SourceSPLD.PanelBorderColor EXISTS
            INCLUDE NewSPLD.PanelBorderColor FROM SourceSPLD.PanelBorderColor
         END
         FOR EACH SourceSPLD.LLD_Block
            // Use recursive routine to duplicate Block.
            DuplicateSPLD_Block( NewSPLD, SourceSPLD )
         END
      END
   END

END

/////////////////////////////////////////////////////////////////////////////
//
//  OPERATION: DuplicateSPLD
//
/////////////////////////////////////////////////////////////////////////////
TRANSFORMATION OPERATION
DuplicateSPLD( VIEW NewSPLD    BASED ON LOD mSPLDef,
               VIEW SourceSPLD BASED ON LOD mSPLDef )

   // Build a new SPLD from an existing SPLD.
   CREATE ENTITY NewSPLD.SubregPhysicalLabelDef
   SetMatchingAttributesByName( NewSPLD, "SubregPhysicalLabelDef", SourceSPLD, "SubregPhysicalLabelDef", zSET_NULL )
   NewSPLD.SubregPhysicalLabelDef.Name = SourceSPLD.SubregPhysicalLabelDef.Name + " (Duplicate)"
   INCLUDE NewSPLD.SubregLabelContent FROM SourceSPLD.SubregLabelContent

   // SPLD_UsageType Entries
   FOR EACH SourceSPLD.SPLD_UsageType
      CREATE ENTITY NewSPLD.SPLD_UsageType
      SetMatchingAttributesByName( NewSPLD, "SPLD_UsageType", SourceSPLD, "SPLD_UsageType", zSET_NULL )
      FOR EACH SourceSPLD.SPLD_Usage
         CREATE ENTITY NewSPLD.SPLD_Usage
         SetMatchingAttributesByName( NewSPLD, "SPLD_Usage", SourceSPLD, "SPLD_Usage", zSET_NULL )
         INCLUDE NewSPLD.S_Usage FROM SourceSPLD.S_Usage
      END
   END

   // SPLD_GeneralSection
   FOR EACH SourceSPLD.SPLD_GeneralSection
      CREATE ENTITY NewSPLD.SPLD_GeneralSection
      SetMatchingAttributesByName( NewSPLD, "SPLD_GeneralSection", SourceSPLD, "SPLD_GeneralSection", zSET_NULL )
      INCLUDE NewSPLD.S_GeneralSection FROM SourceSPLD.S_GeneralSection
      FOR EACH SourceSPLD.SPLD_GeneralStatement
         CREATE ENTITY NewSPLD.SPLD_GeneralStatement
         SetMatchingAttributesByName( NewSPLD, "SPLD_GeneralStatement", SourceSPLD, "SPLD_GeneralStatement", zSET_NULL )
         INCLUDE NewSPLD.S_GeneralStatement FROM SourceSPLD.S_GeneralStatement
      END
   END

   // Ingredients
   FOR EACH SourceSPLD.SPLD_IngredientsSection
      CREATE ENTITY NewSPLD.SPLD_IngredientsSection
      SetMatchingAttributesByName( NewSPLD, "SPLD_IngredientsSection", SourceSPLD, "SPLD_IngredientsSection", zSET_NULL )
      INCLUDE NewSPLD.S_IngredientsSection FROM SourceSPLD.S_IngredientsSection
      FOR EACH SourceSPLD.SPLD_IngredientsStatement
         CREATE ENTITY NewSPLD.SPLD_IngredientsStatement
         SetMatchingAttributesByName( NewSPLD, "SPLD_IngredientsStatement", SourceSPLD, "SPLD_IngredientsStatement", zSET_NULL )
         INCLUDE NewSPLD.S_IngredientsStatement FROM SourceSPLD.S_IngredientsStatement
      END
   END

   // SPLD_StorageDisposalSection
   FOR EACH SourceSPLD.SPLD_StorageDisposalSection
      CREATE ENTITY NewSPLD.SPLD_StorageDisposalSection
      SetMatchingAttributesByName( NewSPLD, "SPLD_StorageDisposalSection", SourceSPLD, "SPLD_StorageDisposalSection", zSET_NULL )
      INCLUDE NewSPLD.S_StorageDisposalSection FROM SourceSPLD.S_StorageDisposalSection
      FOR EACH SourceSPLD.SPLD_StorageDisposalStatement
         CREATE ENTITY NewSPLD.SPLD_StorageDisposalStatement
         SetMatchingAttributesByName( NewSPLD, "SPLD_StorageDisposalStatement", SourceSPLD, "SPLD_StorageDisposalStatement", zSET_NULL )
         INCLUDE NewSPLD.S_StorageDisposalStatement FROM SourceSPLD.S_StorageDisposalStatement
      END
   END

   // SPLD_DirectionsForUseSection
   FOR EACH SourceSPLD.SPLD_DirectionsForUseSection
      CREATE ENTITY NewSPLD.SPLD_DirectionsForUseSection
      SetMatchingAttributesByName( NewSPLD, "SPLD_DirectionsForUseSection", SourceSPLD, "SPLD_DirectionsForUseSection", zSET_NULL )
      INCLUDE NewSPLD.S_DirectionsForUseSection FROM SourceSPLD.S_DirectionsForUseSection
      FOR EACH SourceSPLD.SPLD_DirectionsForUseStatement
         CREATE ENTITY NewSPLD.SPLD_DirectionsForUseStatement
         SetMatchingAttributesByName( NewSPLD, "SPLD_DirectionsForUseStatement", SourceSPLD, "SPLD_DirectionsForUseStatement", zSET_NULL )
         INCLUDE NewSPLD.S_DirectionsForUseStatement FROM SourceSPLD.S_DirectionsForUseStatement

         // UsageOrder entries
         FOR EACH SourceSPLD.SPLD_DirectionsUsageOrdering
            SET CURSOR FIRST NewSPLD.S_Usage WITHIN NewSPLD.SubregPhysicalLabelDef
                       WHERE NewSPLD.S_Usage.ID = SourceSPLD.S_Usage.ID
            IF RESULT >= zCURSOR_SET
               CREATE ENTITY NewSPLD.SPLD_DirectionsUsageOrdering
               SetMatchingAttributesByName( NewSPLD, "SPLD_DirectionsUsageOrdering", SourceSPLD, "SPLD_DirectionsUsageOrdering", zSET_NULL )
               // We need to include the new SPLD_Usage entry created in the NewSPLD.
               INCLUDE NewSPLD.SPLD_DirectionsUsage FROM NewSPLD.SPLD_Usage
            END
         END
      END
   END

   // SPLD_MarketingSection
   FOR EACH SourceSPLD.SPLD_MarketingSection
      CREATE ENTITY NewSPLD.SPLD_MarketingSection
      SetMatchingAttributesByName( NewSPLD, "SPLD_MarketingSection", SourceSPLD, "SPLD_MarketingSection", zSET_NULL )
      INCLUDE NewSPLD.S_MarketingSection FROM SourceSPLD.S_MarketingSection
      FOR EACH SourceSPLD.SPLD_MarketingStatement
         CREATE ENTITY NewSPLD.SPLD_MarketingStatement
         SetMatchingAttributesByName( NewSPLD, "SPLD_MarketingStatement", SourceSPLD, "SPLD_MarketingStatement", zSET_NULL )
         INCLUDE NewSPLD.S_MarketingStatement FROM SourceSPLD.S_MarketingStatement

         // UsageOrder entries
         FOR EACH SourceSPLD.SPLD_MarketingUsageOrdering
            SET CURSOR FIRST NewSPLD.S_Usage WITHIN NewSPLD.SubregPhysicalLabelDef
                       WHERE NewSPLD.S_Usage.ID = SourceSPLD.S_Usage.ID
            IF RESULT >= zCURSOR_SET
               CREATE ENTITY NewSPLD.SPLD_MarketingUsageOrdering
               SetMatchingAttributesByName( NewSPLD, "SPLD_MarketingUsageOrdering", SourceSPLD, "SPLD_MarketingUsageOrdering", zSET_NULL )
               // We need to include the new SPLD_Usage entry created in the NewSPLD.
               INCLUDE NewSPLD.SPLD_MarketingUsage FROM NewSPLD.SPLD_Usage
            END
         END
      END
   END

   // SPLD_HumanHazardSection
   FOR EACH SourceSPLD.SPLD_HumanHazardSection
      CREATE ENTITY NewSPLD.SPLD_HumanHazardSection
      SetMatchingAttributesByName( NewSPLD, "SPLD_HumanHazardSection", SourceSPLD, "SPLD_HumanHazardSection", zSET_NULL )
      IF SourceSPLD.S_HumanHazardSection EXISTS
         INCLUDE NewSPLD.S_HumanHazardSection FROM SourceSPLD.S_HumanHazardSection
      END
   END

   // SPLD_LLD
   CREATE ENTITY NewSPLD.SPLD_LLD
   SetMatchingAttributesByName( NewSPLD, "S_HumanHazardSection", SourceSPLD, "S_HumanHazardSection", zSET_NULL )
   FOR EACH SourceSPLD.LLD_Page
      CREATE ENTITY NewSPLD.LLD_Page
      SetMatchingAttributesByName( NewSPLD, "LLD_Page", SourceSPLD, "LLD_Page", zSET_NULL )
      IF SourceSPLD.PageBackgroundColor EXISTS
         INCLUDE NewSPLD.PageBackgroundColor FROM SourceSPLD.PageBackgroundColor
      END
      FOR EACH SourceSPLD.LLD_Panel
         CREATE ENTITY NewSPLD.LLD_Panel
         SetMatchingAttributesByName( NewSPLD, "LLD_Panel", SourceSPLD, "LLD_Panel", zSET_NULL )
         IF SourceSPLD.PanelBackgroundColor EXISTS
            INCLUDE NewSPLD.PanelBackgroundColor FROM SourceSPLD.PanelBackgroundColor
         END
         IF SourceSPLD.PanelBorderColor EXISTS
            INCLUDE NewSPLD.PanelBorderColor FROM SourceSPLD.PanelBorderColor
         END
         FOR EACH SourceSPLD.LLD_Block
            // Use recursive routine to duplicate Block.
            DuplicateSPLD_Block( NewSPLD, SourceSPLD )
         END
      END
   END

END

/////////////////////////////////////////////////////////////////////////////
//
//  OPERATION: DuplicateSPLD
//
/////////////////////////////////////////////////////////////////////////////
TRANSFORMATION OPERATION
DuplicateSPLD_Block( VIEW NewSPLD    BASED ON LOD mSPLDef,
                     VIEW SourceSPLD BASED ON LOD mSPLDef )

   // This is a recursive routine to duplicate an LLD_Block / LLD_SubBlock.
   CREATE ENTITY NewSPLD.LLD_Block
   SetMatchingAttributesByName( NewSPLD, "LLD_Block", SourceSPLD, "LLD_Block", zSET_NULL )
   IF SourceSPLD.BlockBackgroundColor EXISTS
      INCLUDE NewSPLD.BlockBackgroundColor FROM SourceSPLD.BlockBackgroundColor
   END
   IF SourceSPLD.BlockBorderColor EXISTS
      INCLUDE NewSPLD.BlockBorderColor FROM SourceSPLD.BlockBorderColor
   END
   FOR EACH SourceSPLD.LLD_SpecialSectionAttribute
      CREATE ENTITY NewSPLD.LLD_SpecialSectionAttribute
      SetMatchingAttributesByName( NewSPLD, "LLD_SpecialSectionAttribute", SourceSPLD, "LLD_SpecialSectionAttribute", zSET_NULL )
      CREATE ENTITY NewSPLD.LLD_SpecialSectionAttrBlock
      SetMatchingAttributesByName( NewSPLD, "LLD_SpecialSectionAttrBlock", SourceSPLD, "LLD_SpecialSectionAttrBlock", zSET_NULL )
      IF SourceSPLD.SpecialAttributeTextColor EXISTS
         INCLUDE NewSPLD.SpecialAttributeTextColor FROM SourceSPLD.SpecialAttributeTextColor
      END
   END
   FOR EACH SourceSPLD.LLD_SubBlock
      SetViewToSubobject( SourceSPLD, "LLD_SubBlock" )
      SetViewToSubobject( NewSPLD, "LLD_SubBlock" )

      DuplicateSPLD_Block( NewSPLD, SourceSPLD )

      ResetViewFromSubobject( SourceSPLD )
      ResetViewFromSubobject( NewSPLD )
   END

END

/////////////////////////////////////////////////////////////////////////////
//
//  OPERATION: dFullNameLFM
//
/////////////////////////////////////////////////////////////////////////////
DERIVED ATTRIBUTE OPERATION
dFullNameLFM( VIEW mSPLDef BASED ON LOD mSPLDef,
              STRING ( 32 ) InternalEntityStructure,
              STRING ( 32 ) InternalAttribStructure,
              SHORT GetOrSetFlag )

   CASE GetOrSetFlag
   OF   zDERIVED_GET:
        //PersonName_LastFirstMiddle( mSPLDef, InternalEntityStructure,
        //                            InternalAttribStructure, GetOrSetFlag )

        // end zDERIVED_GET
   OF   zDERIVED_SET:

        // end zDERIVED_SET
   END  // case

END

/////////////////////////////////////////////////////////////////////////////
//
//  OPERATION: dFullNameFML
//
/////////////////////////////////////////////////////////////////////////////
DERIVED ATTRIBUTE OPERATION
dFullNameFML( VIEW mSPLDef BASED ON LOD mSPLDef,
              STRING ( 32 ) InternalEntityStructure,
              STRING ( 32 ) InternalAttribStructure,
              SHORT GetOrSetFlag )

   CASE GetOrSetFlag
   OF   zDERIVED_GET:

        PersonName_FirstMiddleLast( mSPLDef, InternalEntityStructure,
                                    InternalAttribStructure, GetOrSetFlag )

        // end zDERIVED_GET
   OF   zDERIVED_SET:

        // end zDERIVED_SET
   END  // case

END

/////////////////////////////////////////////////////////////////////////////
//
//  OPERATION: dPrimRegNameID
//  Registrant Name + EPA Registrant Number
//
/////////////////////////////////////////////////////////////////////////////
DERIVED ATTRIBUTE OPERATION
dPrimRegNameID( VIEW mSPLDef BASED ON LOD mSPLDef,
                STRING ( 32 ) InternalEntityStructure,
                STRING ( 32 ) InternalAttribStructure,
                SHORT GetOrSetFlag )

   STRING ( 1000 ) szString

   CASE GetOrSetFlag
   OF   zDERIVED_GET:

      IF mSPLDef.Organization EXISTS
         szString = mSPLDef.Organization.Name
         IF mSPLDef.PrimaryRegistrant.EPA_CompanyNumber != ""
            szString = szString + " (" +
                       mSPLDef.PrimaryRegistrant.EPA_CompanyNumber + ")"
         END
       ELSE
          szString = ""
       END
       // Store the calculated value in the object.
       StoreStringInRecord( mSPLDef,
                            InternalEntityStructure, InternalAttribStructure, szString )
       RETURN 0

        // end zDERIVED_GET
   OF   zDERIVED_SET:

        // end zDERIVED_SET
   END  // case

END

/////////////////////////////////////////////////////////////////////////////
//
//  OPERATION: dSubregNameID
//  Registrant Name + EPA Registrant Number
//
/////////////////////////////////////////////////////////////////////////////
DERIVED ATTRIBUTE OPERATION
dSubregNameID( VIEW mSPLDef BASED ON LOD mSPLDef,
               STRING ( 32 ) InternalEntityStructure,
               STRING ( 32 ) InternalAttribStructure,
               SHORT GetOrSetFlag )

   STRING ( 1000 ) szString

   CASE GetOrSetFlag
   OF   zDERIVED_GET:

      IF mSPLDef.SubregOrganization EXISTS
         szString = mSPLDef.SubregOrganization.Name
         IF mSPLDef.Subregistrant.EPA_CompanyNumber != ""
            szString = szString + " (" +
                       mSPLDef.Subregistrant.EPA_CompanyNumber + ")"
         END
       ELSE
          szString = ""
       END
       // Store the calculated value in the object.
       StoreStringInRecord( mSPLDef,
                            InternalEntityStructure, InternalAttribStructure, szString )
       RETURN 0

        // end zDERIVED_GET
   OF   zDERIVED_SET:

        // end zDERIVED_SET
   END  // case

END

/////////////////////////////////////////////////////////////////////////////
//
//  OPERATION: dIngredientName
//
/////////////////////////////////////////////////////////////////////////////
DERIVED ATTRIBUTE OPERATION
dIngredientName( VIEW mSPLDef BASED ON LOD mSPLDef,
                 STRING ( 32 ) InternalEntityStructure,
                 STRING ( 32 ) InternalAttribStructure,
                 SHORT GetOrSetFlag )

   STRING ( 1000 ) szString

   CASE GetOrSetFlag
   OF   zDERIVED_GET:

      IF mSPLDef.S_IngredientsStatement EXISTS
         szString = mSPLDef.SPLD_IngredientsStatement.CommonName
      IF szString = ""
            szString = mSPLDef.SPLD_IngredientsStatement.ChemicalName
         END
       ELSE
          szString = ""
       END
       // Store the calculated value in the object.
       StoreStringInRecord( mSPLDef,
                            InternalEntityStructure, InternalAttribStructure, szString )
       RETURN 0

        // end zDERIVED_GET
   OF   zDERIVED_SET:

        // end zDERIVED_SET
   END  // case

END

/////////////////////////////////////////////////////////////////////////////
//
// OPERATION: dGenStmtTitleText
//
/////////////////////////////////////////////////////////////////////////////
DERIVED ATTRIBUTE OPERATION
dGenStmtTitleText( VIEW mSPLDef BASED ON LOD mSPLDef,
                   STRING ( 32 ) InternalEntityStructure,
                   STRING ( 32 ) InternalAttribStructure,
                   SHORT GetOrSetFlag )

// VIEW mSPLDef2 BASED ON LOD mSPLDef
   STRING ( 2048 ) szCombinedText

   CASE GetOrSetFlag
   OF   zDERIVED_GET:

      // If Combined and a Title exists, concatenate Title and Text.  Otherwise, just show text.
      // Bold Title and Text as specified.
      IF mSPLDef.SPLD_GeneralSection.Combined = "Y" AND mSPLDef.SPLD_GeneralStatement.Title != ""
         IF mSPLDef.SPLD_GeneralSection.BoldTitle = "Y"
            szCombinedText = "<b>" + mSPLDef.SPLD_GeneralStatement.Title + "</b>"
         ELSE
            szCombinedText = mSPLDef.SPLD_GeneralStatement.Title
         END
      END
      IF mSPLDef.SPLD_GeneralSection.BoldText = "Y"
         szCombinedText = szCombinedText + "<b> " + mSPLDef.SPLD_GeneralStatement.Text + "</b>"
      ELSE
         szCombinedText = szCombinedText + " " + mSPLDef.SPLD_GeneralStatement.Text
      END

      // Store the calculated value in the object.
      StoreStringInRecord( mSPLDef, InternalEntityStructure, InternalAttribStructure, szCombinedText )

        // end zDERIVED_GET
   OF   zDERIVED_SET:

        // end zDERIVED_SET
   END  // case

END

/////////////////////////////////////////////////////////////////////////////
//
//  OPERATION: dPanelName
//
/////////////////////////////////////////////////////////////////////////////
DERIVED ATTRIBUTE OPERATION
dPanelName( VIEW mSPLDef BASED ON LOD mSPLDef,
            STRING ( 32 ) InternalEntityStructure,
            STRING ( 32 ) InternalAttribStructure,
            SHORT GetOrSetFlag )

   STRING ( 16 ) szPanelName

   CASE GetOrSetFlag
   OF   zDERIVED_GET:

   // Currently the Panel Name is just the "panel" + Panel Number.
   /*szPanelName = "Panel"
   //szPanelName = szPanelName + mSPLDef.SPLD_TemplatePanel.wSequentialPanelNumber
   // Store the calculated value in the object.
   StoreStringInRecord( mSPLDef,
                        InternalEntityStructure, InternalAttribStructure, szPanelName )*/

        // end zDERIVED_GET
   OF   zDERIVED_SET:

        // end zDERIVED_SET
   END  // case

END

/////////////////////////////////////////////////////////////////////////////
//
//  OPERATION: dSectionIdentifier
//
/////////////////////////////////////////////////////////////////////////////
DERIVED ATTRIBUTE OPERATION
dSectionIdentifier( VIEW mSPLDef BASED ON LOD mSPLDef,
                    STRING ( 32 ) InternalEntityStructure,
                    STRING ( 32 ) InternalAttribStructure,
                    SHORT GetOrSetFlag )

   STRING ( 16 ) szSectionIdentifier

   CASE GetOrSetFlag
   OF   zDERIVED_GET:

   // This is the Section Type, unless the Section Type is Marketing, in which case the Section Name is added on.
   IF mSPLDef.LLD_Block.LLD_SectionType = "Marketing"
      szSectionIdentifier = "Marketing - " + mSPLDef.LLD_Block.Name
   ELSE
      szSectionIdentifier = mSPLDef.LLD_Block.LLD_SectionType
   END
   StoreStringInRecord( mSPLDef,
                        InternalEntityStructure, InternalAttribStructure, szSectionIdentifier )

        // end zDERIVED_GET
   OF   zDERIVED_SET:

        // end zDERIVED_SET
   END  // case

END

/////////////////////////////////////////////////////////////////////////////
//
//  OPERATION: dMasterProductNameNbr
//
/////////////////////////////////////////////////////////////////////////////
DERIVED ATTRIBUTE OPERATION
dMasterProductNameNbr( VIEW mSPLDef BASED ON LOD mSPLDef,
                       STRING ( 32 ) InternalEntityStructure,
                       STRING ( 32 ) InternalAttribStructure,
                       SHORT GetOrSetFlag )

   STRING ( 1000 ) szString

   CASE GetOrSetFlag
   OF   zDERIVED_GET:

      IF mSPLDef.MasterProduct  EXISTS
         szString = mSPLDef.MasterProduct.Name + " (" +
                    mSPLDef.PrimaryRegistrant.EPA_CompanyNumber + "-" +
                    mSPLDef.MasterProduct.Number + ")"
       ELSE
          szString = ""
       END
       // Store the calculated value in the object.
       StoreStringInRecord( mSPLDef,
                            InternalEntityStructure, InternalAttribStructure, szString )
       RETURN 0

        // end zDERIVED_GET
   OF   zDERIVED_SET:

        // end zDERIVED_SET
   END  // case

END


/////////////////////////////////////////////////////////////////////////////
//
//  OPERATION: dSubregProductNameNbr
//
/////////////////////////////////////////////////////////////////////////////
DERIVED ATTRIBUTE OPERATION
dSubregProductNameNbr( VIEW mSPLDef BASED ON LOD mSPLDef,
                       STRING ( 32 ) InternalEntityStructure,
                       STRING ( 32 ) InternalAttribStructure,
                       SHORT GetOrSetFlag )

   STRING ( 1000 ) szString

   CASE GetOrSetFlag
   OF   zDERIVED_GET:

       szString = mSPLDef.SubregProduct.Name
       IF mSPLDef.SubregProduct.Number != 0
          szString = szString + " (" + mSPLDef.SubregProduct.Number + ")"
       END
       // Store the calculated value in the object.
       StoreStringInRecord( mSPLDef,
                            InternalEntityStructure, InternalAttribStructure, szString )
       RETURN 0

        // end zDERIVED_GET
   OF   zDERIVED_SET:

        // end zDERIVED_SET
   END  // case

END

/////////////////////////////////////////////////////////////////////////////
//
//  OPERATION: dDisplayPathogenName
//
/////////////////////////////////////////////////////////////////////////////
DERIVED ATTRIBUTE OPERATION
dDisplayPathogenName( VIEW mSPLDef BASED ON LOD mSPLDef,
                      STRING ( 32 ) InternalEntityStructure,
                      STRING ( 32 ) InternalAttribStructure,
                      SHORT GetOrSetFlag )

   VIEW mSPLDef2 BASED ON LOD mSPLDef
   STRING ( 32 )  szEntityName
   STRING ( 100 ) szUsageType
   STRING ( 100 ) szClassification
   STRING ( 100 ) szCombinedName
   STRING ( 3 )   szFootnoteNumber
   INTEGER        Count

   CASE GetOrSetFlag
   OF   zDERIVED_GET:

      // Combine the Footnote Number as a subscript to the Claim Name, if it exists.
      szCombinedName = mSPLDef.SPLD_Usage.Name

      // Set Footnote Number, if footnote exists.
      IF mSPLDef.SPLD_UsageFootnoteUsed EXISTS
         SET CURSOR FIRST mSPLDef.SPLD_UsageFootnote WHERE mSPLDef.SPLD_UsageFootnote.ID = mSPLDef.SPLD_UsageFootnoteUsed.ID
         IF mSPLDef.SPLD_UsageFootnote.wFootNoteRelativeNumber = ""
            // Relative numbers haven't be set, so set them here.
            CreateViewFromView( mSPLDef2, mSPLDef )
            Count = 0
            FOR EACH mSPLDef2.SPLD_UsageFootnote
               Count = Count + 1
               mSPLDef2.SPLD_UsageFootnote.wFootNoteRelativeNumber = Count
            END
            DropView( mSPLDef2 )
         END
         szFootnoteNumber = mSPLDef.SPLD_UsageFootnote.wFootNoteRelativeNumber
         szCombinedName = szCombinedName + "<sup> " + szFootnoteNumber + "</sup>"
      END

      // Store the calculated value in the object.
      StoreStringInRecord( mSPLDef,
                           InternalEntityStructure,
                           InternalAttribStructure, szCombinedName )

        // end zDERIVED_GET
   OF   zDERIVED_SET:

        // end zDERIVED_SET
   END  // case

END

/////////////////////////////////////////////////////////////////////////////
//
//  OPERATION: dDisplayUsageName
//
/////////////////////////////////////////////////////////////////////////////
DERIVED ATTRIBUTE OPERATION
dDisplayUsageName( VIEW mSPLDef BASED ON LOD mSPLDef,
                   STRING ( 32 ) InternalEntityStructure,
                   STRING ( 32 ) InternalAttribStructure,
                   SHORT GetOrSetFlag )

   VIEW mSPLDef2 BASED ON LOD mSPLDef
   STRING ( 32 )  szEntityName
   STRING ( 100 ) szUsageType
   STRING ( 100 ) szClassification
   STRING ( 100 ) szName
   STRING ( 100 ) szCombinedName
   STRING ( 3 )   szFootnoteNumber
   INTEGER        Count

   CASE GetOrSetFlag
   OF   zDERIVED_GET:

      // For a Claim Usage entity, this is the combined name of Classification and Name.
      // For all others, it is simply the name.
      GetEntityNameFromStructure( InternalEntityStructure, szEntityName )
      GetStringFromAttribute( szUsageType, mSPLDef, szEntityName, "UsageType" )
      GetStringFromAttribute( szClassification, mSPLDef, szEntityName, "ClaimsClassification" )
      GetStringFromAttribute( szName, mSPLDef, szEntityName, "Name" )
      IF szUsageType = "C"
         szCombinedName = szClassification + " - " + szName
      ELSE
         szCombinedName = szName
      END

      // Set Footnote Number, if footnote exists.
      IF mSPLDef.S_UsageFootnoteUsed EXISTS
         IF mSPLDef.S_UsageFootnoteUsed.ID != ""
            SET CURSOR FIRST mSPLDef.SPLD_UsageFootnote WHERE mSPLDef.SPLD_UsageFootnote.ID = mSPLDef.SPLD_UsageFootnoteUsed.ID
            IF mSPLDef.SPLD_UsageFootnote.wFootNoteRelativeNumber = ""
               // Relative numbers haven't be set, so set them here.
               CreateViewFromView( mSPLDef2, mSPLDef )
               Count = 0
               FOR EACH mSPLDef2.SPLD_UsageFootnote
                  Count = Count + 1
                  mSPLDef2.SPLD_UsageFootnote.wFootNoteRelativeNumber = Count
               END
               DropView( mSPLDef2 )
            END
            szFootnoteNumber = mSPLDef.SPLD_UsageFootnote.wFootNoteRelativeNumber
            szCombinedName = szCombinedName + "<sup> " + szFootnoteNumber + "</sup>"
         END
      END

      // Store the calculated value in the object.
      StoreStringInRecord( mSPLDef,
                           InternalEntityStructure,
                           InternalAttribStructure, szCombinedName )

        // end zDERIVED_GET
   OF   zDERIVED_SET:

        // end zDERIVED_SET
   END  // case

END

/////////////////////////////////////////////////////////////////////////////
//
//  OPERATION: dFullHazardStatement
//
/////////////////////////////////////////////////////////////////////////////
DERIVED ATTRIBUTE OPERATION
dFullHazardStatement( VIEW mSPLDef BASED ON LOD mSPLDef,
                      STRING ( 32 ) InternalEntityStructure,
                      STRING ( 32 ) InternalAttribStructure,
                      SHORT GetOrSetFlag )

   STRING ( 256 ) szString
   STRING ( 256 ) szReplaceString
   STRING ( 256 ) szLocation
   STRING ( 2 )   szSeparator
   STRING ( 1 )   szOpenSeparator
   STRING ( 1 )   szCloseSeparator
   STRING ( 1 )   szEncloseFirst
   SHORT nPosStart
   SHORT nPosEnd

   CASE GetOrSetFlag
   OF   zDERIVED_GET:

      IF mSPLDef.SPLD_HumanHazardSection  EXISTS

         szSeparator = mSPLDef.SPLD_HumanHazardSection.LocationSeparator
         szOpenSeparator = ""
         szCloseSeparator = ""
         nPosStart  = zstrlen( szSeparator )
         IF nPosStart > 0
            zstrncpy( szOpenSeparator, szSeparator, 1 )
            IF nPosStart > 1
               zstrncpyoffset( szCloseSeparator, szSeparator, 1, 1 )
            END
         END

         szEncloseFirst = mSPLDef.SPLD_HumanHazardSection.EncloseFirstLocation
         szString = mSPLDef.SPLD_HumanHazardSection.PrecautionaryStatement
         nPosStart  = zSearchSubString( szString, "{{Precautionary Panel Location}}", "f", 0 )
         IF nPosStart >= 0

            nPosEnd = nPosStart + 32 // length of "{{Precautionary Panel Location}}"
            szReplaceString = ""
            szLocation = mSPLDef.SPLD_HumanHazardSection.PanelLoc1
            IF szLocation != ""
               IF szEncloseFirst = "Y" AND szCloseSeparator != ""
                  szReplaceString = szReplaceString + szOpenSeparator + szLocation + szCloseSeparator
               ELSE
                  szReplaceString = szReplaceString + szLocation
               END
            END

            szLocation = mSPLDef.SPLD_HumanHazardSection.PanelLoc2
            IF szLocation != ""
               szReplaceString = szReplaceString + szOpenSeparator + szLocation + szCloseSeparator
            END

            szLocation = mSPLDef.SPLD_HumanHazardSection.PanelLoc3
            IF szLocation != ""
               szReplaceString = szReplaceString + szOpenSeparator + szLocation + szCloseSeparator
            END

            szLocation = mSPLDef.SPLD_HumanHazardSection.PanelLoc4
            IF szLocation != ""
               szReplaceString = szReplaceString + szOpenSeparator + szLocation + szCloseSeparator
            END

            szLocation = mSPLDef.SPLD_HumanHazardSection.PanelLoc5
            IF szLocation != ""
               szReplaceString = szReplaceString + szOpenSeparator + szLocation + szCloseSeparator
            END

            szLocation = mSPLDef.SPLD_HumanHazardSection.PanelLoc6
            IF szLocation != ""
               szReplaceString = szReplaceString + szOpenSeparator + szLocation + szCloseSeparator
            END

            szLocation = mSPLDef.SPLD_HumanHazardSection.PanelLoc7
            IF szLocation != ""
               szReplaceString = szReplaceString + szOpenSeparator + szLocation + szCloseSeparator
            END

            szLocation = mSPLDef.SPLD_HumanHazardSection.PanelLoc8
            IF szLocation != ""
               szReplaceString = szReplaceString + szOpenSeparator + szLocation + szCloseSeparator
            END

            szLocation = mSPLDef.SPLD_HumanHazardSection.PanelLoc9
            IF szLocation != ""
               szReplaceString = szReplaceString + szOpenSeparator + szLocation + szCloseSeparator
            END

            zReplaceSubString( szString, nPosStart, nPosEnd, szReplaceString )
         END

         nPosStart  = zSearchSubString( szString, "{{Precautionary Label Location}}", "f", 0 )
         IF nPosStart >= 0

            nPosEnd = nPosStart + 32 // length of "{{Precautionary Label Location}}"
            szReplaceString = ""
            szLocation = mSPLDef.SPLD_HumanHazardSection.LabelLoc1
            IF szLocation != ""
               IF szCloseSeparator != ""
                  szReplaceString = szReplaceString + szOpenSeparator + szLocation + szCloseSeparator
               ELSE
                  szReplaceString = szReplaceString + szLocation
               END
            END

            szLocation = mSPLDef.SPLD_HumanHazardSection.LabelLoc2
            IF szLocation != ""
               szReplaceString = szReplaceString + szOpenSeparator + szLocation + szCloseSeparator
            END

            szLocation = mSPLDef.SPLD_HumanHazardSection.LabelLoc3
            IF szLocation != ""
               szReplaceString = szReplaceString + szOpenSeparator + szLocation + szCloseSeparator
            END

            szLocation = mSPLDef.SPLD_HumanHazardSection.LabelLoc4
            IF szLocation != ""
               szReplaceString = szReplaceString + szOpenSeparator + szLocation + szCloseSeparator
            END

            szLocation = mSPLDef.SPLD_HumanHazardSection.LabelLoc5
            IF szLocation != ""
               szReplaceString = szReplaceString + szOpenSeparator + szLocation + szCloseSeparator
            END

            szLocation = mSPLDef.SPLD_HumanHazardSection.LabelLoc6
            IF szLocation != ""
               szReplaceString = szReplaceString + szOpenSeparator + szLocation + szCloseSeparator
            END

            szLocation = mSPLDef.SPLD_HumanHazardSection.LabelLoc7
            IF szLocation != ""
               szReplaceString = szReplaceString + szOpenSeparator + szLocation + szCloseSeparator
            END

            szLocation = mSPLDef.SPLD_HumanHazardSection.LabelLoc8
            IF szLocation != ""
               szReplaceString = szReplaceString + szOpenSeparator + szLocation + szCloseSeparator
            END

            szLocation = mSPLDef.SPLD_HumanHazardSection.LabelLoc9
            IF szLocation != ""
               szReplaceString = szReplaceString + szOpenSeparator + szLocation + szCloseSeparator
            END

            zReplaceSubString( szString, nPosStart, nPosEnd, szReplaceString )
         END

      ELSE
         szString = ""
      END

      // Store the calculated value in the object.
      StoreStringInRecord( mSPLDef, InternalEntityStructure, InternalAttribStructure, szString )
      RETURN 0

      // end zDERIVED_GET
   OF   zDERIVED_SET:

      // end zDERIVED_SET
   END  // case

END

/////////////////////////////////////////////////////////////////////////////
//
//  OPERATION: dSelectedHazardStmt
//
/////////////////////////////////////////////////////////////////////////////
DERIVED ATTRIBUTE OPERATION
dSelectedHazardStmt( VIEW mSPLDef BASED ON LOD mSPLDef,
                     STRING ( 32 ) InternalEntityStructure,
                     STRING ( 32 ) InternalAttribStructure,
                     SHORT GetOrSetFlag )

   STRING ( 2048 ) szString
   STRING ( 2048 ) szReplaceString
   STRING ( 2048 ) szLocation
   SHORT nPosStart
   SHORT nPosEnd
   SHORT nLth

   CASE GetOrSetFlag
   OF   zDERIVED_GET:

      szString = ""

      // Build Precautionary Statement by inserting correct Location within general statement, so that a
      // statement such as, "See {{Precautionary Panel Location}}" for Precautionary Statements and First Aid." becomes
      // "See side panel for Precautionary Statements and First Aid."
      IF mSPLDef.SPLD_HumanHazardSection EXISTS
         szString = mSPLDef.SPLD_HumanHazardSection.PrecautionaryStatement
         nPosStart = zSearchSubString( szString, "[{{Precautionary Panel Location}}]", "f", 0 )
         IF nPosStart >= 0
            nPosEnd = nPosStart + 34 // length of "[{{Precautionary Panel Location}}]"
         ELSE
            nPosStart = zSearchSubString( szString, "{{Precautionary Panel Location}}", "f", 0 )
            IF nPosStart >= 0
               nPosEnd = nPosStart + 32 // length of "{{Precautionary Panel Location}}"
            END
         END
         IF nPosStart >= 0
            szLocation = mSPLDef.SPLD_HumanHazardSection.PanelLoc
            zSearchAndReplace( szLocation, 2048, ",", " ")
            zReplaceSubString( szString, nPosStart, nPosEnd, szLocation )
         END

         nPosStart = zSearchSubString( szString, "[{{Precautionary Label Location}}]", "f", 0 )
         IF nPosStart >= 0
            nPosEnd = nPosStart + 34 // length of "[{{Precautionary Label Location}}]"
         ELSE
            nPosStart = zSearchSubString( szString, "{{Precautionary Label Location}}", "f", 0 )
            IF nPosStart >= 0
               nPosEnd = nPosStart + 32 // length of "{{Precautionary Label Location}}"
            END
         END
         IF nPosStart >= 0
            szLocation = mSPLDef.SPLD_HumanHazardSection.LabelLoc
            zSearchAndReplace( szLocation, 2048, ",", " ")
            zReplaceSubString( szString, nPosStart, nPosEnd, szLocation )
         END

         RemovePairedCharactersFromString( szString, "{", "}", "" )
      END
   // TraceLineS( "Hazard Statement: ", szString )
      // Store the calculated value in the object.
      StoreStringInRecord( mSPLDef, InternalEntityStructure, InternalAttribStructure, szString )

      // end zDERIVED_GET
   OF   zDERIVED_SET:

        // end zDERIVED_SET
   END  // case

END

/////////////////////////////////////////////////////////////////////////////
//
//  OPERATION: GetLPLR_SourceDirectory
//
/////////////////////////////////////////////////////////////////////////////
LOCAL OPERATION
GetLPLR_SourceDirectory( VIEW mSPLDef BASED ON LOD mSPLDef,
                         STRING ( 400 ) ReturnedDirectory )

   VIEW vTZZOLFLO
   STRING ( 400 ) szFileName
   STRING ( 32 )  szApplicationName
   STRING ( 200 ) szMsg
   SHORT          nRC

   // Return the LPLR Source directory to the caller.
   // We will get it from the MetaSource directory in the XLP, which speicifies the source of the Query
   // View list for both read and write.

   // Try to use the existing view.
   GET VIEW vTZZOLFLO NAMED "TZZOLFLO"
   IF RESULT < 0
      // Get the XLP directory structure and file name.
      GetApplDirectoryFromView( szFileName, mSPLDef, zAPPL_DIR_OBJECT, 400 )
      GetCurrentApplicationName( szApplicationName, 32, mSPLDef )
      szFileName = szFileName + szApplicationName + ".XLP"
      // Activate the XLP to the query LODs.
      // 536870912 is ACTIVATE_SYSTEM in the following activate statement.
      nRC = ActivateOI_FromFile( vTZZOLFLO, "TZCMLPLO", mSPLDef, szFileName, 536870912 )
      IF nRC < 0
         szMsg = "Cannot activate the Query .XLP from executable directory, " + szFileName + "."
         MessageSend( mSPLDef, "", "Open Query",
                      szMsg,
                      zMSGQ_OBJECT_CONSTRAINT_ERROR, 0 )
         SetWindowActionBehavior( mSPLDef, zWAB_StayOnWindow, "", "" )
         RETURN -1
      END
      NAME VIEW vTZZOLFLO "TZZOLFLO"
   END
   // Get the Meta Source name from the root.
   GetStringFromAttribute( ReturnedDirectory, vTZZOLFLO, "LPLR", "MetaSrcDir" )

END


/////////////////////////////////////////////////////////////////////////////
//
//  OPERATION: GenerateXML_File
//
/////////////////////////////////////////////////////////////////////////////
TRANSFORMATION OPERATION
GenerateXML_File( VIEW mSPLDef BASED ON LOD mSPLDef,
                  STRING ( 32 )  szTopEntityName,
                  STRING ( 300 ) szXmlDirectoryAndFileName )

   STRING ( 50 )   szIndentation
   STRING ( 400 )  szMsg
   STRING ( 400 )  szFileName
   STRING ( 5000 ) szValue
   STRING ( 5000 ) szOutputLine
   STRING ( 50 )   szSectionName
   STRING ( 50 )   szStatementName
   STRING ( 50 )   szDateTimeDisplay
   INTEGER         lFileHandle
   SHORT           nRC

   // Build an XML object from selected entries in the mSPLDef object instance.

   // Open XML output file.
   lFileHandle = SysOpenFile( mSPLDef, szXmlDirectoryAndFileName, COREFILE_WRITE )
   IF lFileHandle < 0
      szMsg = "Cannot open XML Output File, " + szXmlDirectoryAndFileName
      MessageSend( mSPLDef, "", "Generate XSLT",
                   szMsg, zMSGQ_OBJECT_CONSTRAINT_WARNING, 0 )
      RETURN -1
   END

   // Build Header entries.
   szOutputLine = "<?xml version=" + QUOTES + "1.0" + QUOTES + "?>"
   GenerateLine( mSPLDef, lFileHandle, szOutputLine )
   GetStringFromAttributeByContext( szDateTimeDisplay, mSPLDef, "SubregPhysicalLabelDef", "wDateTime", "YYYY/MM/DD HH:MM:SS.S AM", 30 )
   szOutputLine = "<!-- Output created by ePamms   " + szDateTimeDisplay + " -->"
   GenerateLine( mSPLDef, lFileHandle, szOutputLine )

   szOutputLine = "   <zOI>"
   GenerateLine( mSPLDef, lFileHandle, szOutputLine )
   szOutputLine = "      <SubregPhysicalLabelDef>"
   GenerateLine( mSPLDef, lFileHandle, szOutputLine )

   szIndentation = "         "
   szValue = mSPLDef.SubregPhysicalLabelDef.Name
   GenerateAttribute( mSPLDef, lFileHandle, "Name", szIndentation, szValue )
   szValue = mSPLDef.SubregPhysicalLabelDef.ProductName
   GenerateAttribute( mSPLDef, lFileHandle, "ProductName", szIndentation, szValue )

   // <SubregLabelContent>
   szOutputLine = "         <SubregLabelContent>"
   GenerateLine( mSPLDef, lFileHandle, szOutputLine )
   szIndentation = "            "
   szValue = mSPLDef.SubregLabelContent.EPA_RegistrationNumber
   GenerateAttribute( mSPLDef, lFileHandle, "EPA_RegistrationNumber", szIndentation, szValue )
   szValue = mSPLDef.SubregLabelContent.EPA_EstablishmentNumber
   GenerateAttribute( mSPLDef, lFileHandle, "EPA_EstablishmentNumber", szIndentation, szValue )
   szValue = mSPLDef.SubregLabelContent.ESL_Date
   GenerateAttribute( mSPLDef, lFileHandle, "ESL_Date", szIndentation, szValue )
   szOutputLine = "         </SubregLabelContent>"
   GenerateLine( mSPLDef, lFileHandle, szOutputLine )

   // <SPLD_GeneralSection>
   FOR EACH mSPLDef.SPLD_GeneralSection
      szOutputLine = "         <SPLD_GeneralSection>"
      GenerateLine( mSPLDef, lFileHandle, szOutputLine )
      szIndentation = "            "
      szValue = mSPLDef.SPLD_GeneralSection.Title
      GenerateAttribute( mSPLDef, lFileHandle, "Title", szIndentation, szValue )
      szValue = mSPLDef.SPLD_GeneralSection.Subtitle
      GenerateAttribute( mSPLDef, lFileHandle, "Subtitle", szIndentation, szValue )

      // <SPLD_GeneralStatement>
      FOR EACH mSPLDef.SPLD_GeneralStatement
         szOutputLine = "            <SPLD_GeneralStatement>"
         GenerateLine( mSPLDef, lFileHandle, szOutputLine )
         szIndentation = "               "
         szValue = mSPLDef.SPLD_GeneralStatement.Text
         GenerateAttribute( mSPLDef, lFileHandle, "Text", szIndentation, szValue )
         szOutputLine = "            </SPLD_GeneralStatement>"
         GenerateLine( mSPLDef, lFileHandle, szOutputLine )
      END

      szOutputLine = "         </SPLD_GeneralSection>"
      GenerateLine( mSPLDef, lFileHandle, szOutputLine )
   END

   // <SPLD_IngredientsSection>
   FOR EACH mSPLDef.SPLD_IngredientsSection
      szOutputLine = "         <SPLD_IngredientsSection>"
      GenerateLine( mSPLDef, lFileHandle, szOutputLine )
      szIndentation = "            "
      szValue = mSPLDef.SPLD_IngredientsSection.ActiveTitle
      GenerateAttribute( mSPLDef, lFileHandle, "ActiveTitle", szIndentation, szValue )
      szValue = mSPLDef.SPLD_IngredientsSection.InertTitle
      GenerateAttribute( mSPLDef, lFileHandle, "InertTitle", szIndentation, szValue )
      szValue = mSPLDef.SPLD_IngredientsSection.GeneralInactivePercent
      GenerateAttribute( mSPLDef, lFileHandle, "GeneralInactivePercent", szIndentation, szValue )

      // <SPLD_IngredientsStatement>
      FOR EACH mSPLDef.SPLD_IngredientsStatement
         szOutputLine = "            <SPLD_IngredientsStatement>"
         GenerateLine( mSPLDef, lFileHandle, szOutputLine )
         szIndentation = "               "
         szValue = mSPLDef.SPLD_IngredientsStatement.ChemicalName
         GenerateAttribute( mSPLDef, lFileHandle, "ChemicalName", szIndentation, szValue )
         szValue = mSPLDef.SPLD_IngredientsStatement.Percent
         GenerateAttribute( mSPLDef, lFileHandle, "Percent", szIndentation, szValue )
         szOutputLine = "            </SPLD_IngredientsStatement>"
         GenerateLine( mSPLDef, lFileHandle, szOutputLine )
      END

      szOutputLine = "         </SPLD_IngredientsSection>"
      GenerateLine( mSPLDef, lFileHandle, szOutputLine )
   END

   // <SPLD_StorageDisposalSection>
   /*FOR EACH mSPLDef.SPLD_StorageDisposalSection
      szOutputLine = "         <SPLD_StorageDisposalSection>"
      GenerateLine( mSPLDef, lFileHandle, szOutputLine )
      szIndentation = "            "
      szValue = mSPLDef.SPLD_StorageDisposalSection.Title
      GenerateAttribute( mSPLDef, lFileHandle, "Title", szIndentation, szValue )
      // <SPLD_StorageDisposalStatement>
      FOR EACH mSPLDef.SPLD_StorageDisposalStatement
         szOutputLine = "            <SPLD_StorageDisposalStatement>"
         GenerateLine( mSPLDef, lFileHandle, szOutputLine )
         szIndentation = "               "
         szValue = mSPLDef.SPLD_StorageDisposalStatement.Title
         GenerateAttribute( mSPLDef, lFileHandle, "Title", szIndentation, szValue )
         szValue = mSPLDef.SPLD_StorageDisposalStatement.Text
         GenerateAttribute( mSPLDef, lFileHandle, "Text", szIndentation, szValue )
         szOutputLine = "            </SPLD_StorageDisposalStatement>"
         GenerateLine( mSPLDef, lFileHandle, szOutputLine )
      END
      szOutputLine = "         </SPLD_StorageDisposalSection>"
      GenerateLine( mSPLDef, lFileHandle, szOutputLine )
   END
   // <SPLD_DirectionsForUseSection>
   FOR EACH mSPLDef.SPLD_DirectionsForUseSection
      szOutputLine = "         <SPLD_DirectionsForUseSection>"
      GenerateLine( mSPLDef, lFileHandle, szOutputLine )
      szIndentation = "            "
      szValue = mSPLDef.SPLD_DirectionsForUseSection.Title
      GenerateAttribute( mSPLDef, lFileHandle, "Title", szIndentation, szValue )
      // <SPLD_DirectionsForUseStatement>
      FOR EACH mSPLDef.SPLD_DirectionsForUseStatement
         szOutputLine = "            <SPLD_DirectionsForUseStatement>"
         GenerateLine( mSPLDef, lFileHandle, szOutputLine )
         szIndentation = "               "
         szValue = mSPLDef.SPLD_DirectionsForUseStatement.Title
         GenerateAttribute( mSPLDef, lFileHandle, "Title", szIndentation, szValue )
         szValue = mSPLDef.SPLD_DirectionsForUseStatement.wkDisplayText     // We'll use wkDisplayText because it includes inserted characters.
         GenerateAttribute( mSPLDef, lFileHandle, "Text", szIndentation, szValue )
         szOutputLine = "            </SPLD_DirectionsForUseStatement>"
         GenerateLine( mSPLDef, lFileHandle, szOutputLine )
      END
      // <SPLD_DirectionsUsageOrdering>
      FOR EACH mSPLDef.SPLD_DirectionsUsageOrdering
         szOutputLine = "         <SPLD_DirectionsUsageOrdering>"
         GenerateLine( mSPLDef, lFileHandle, szOutputLine )
         szIndentation = "            "
         szValue = mSPLDef.SPLD_DirectionsUsageOrdering.wSortOrder
         GenerateAttribute( mSPLDef, lFileHandle, "wSortOrder", szIndentation, szValue )
         // <SPLD_DirectionsUsageOrdering>
         szOutputLine = "            <SPLD_DirectionsUsage>"
         GenerateLine( mSPLDef, lFileHandle, szOutputLine )
         szIndentation = "               "
         szValue = mSPLDef.SPLD_DirectionsUsage.UsageType
         GenerateAttribute( mSPLDef, lFileHandle, "UsageType", szIndentation, szValue )
         szValue = mSPLDef.SPLD_DirectionsUsage.Name
         GenerateAttribute( mSPLDef, lFileHandle, "Name", szIndentation, szValue )
         szOutputLine = "            </SPLD_DirectionsUsage>"
         GenerateLine( mSPLDef, lFileHandle, szOutputLine )
         szOutputLine = "         </SPLD_DirectionsUsageOrdering>"
         GenerateLine( mSPLDef, lFileHandle, szOutputLine )
      END
      szOutputLine = "         </SPLD_DirectionsForUseSection>"
      GenerateLine( mSPLDef, lFileHandle, szOutputLine )
   END
   // <SPLD_MarketingSection>
   FOR EACH mSPLDef.SPLD_MarketingSection
      // The Marketing Section name includes the Sequence Number to get uniqueness
      szSectionName = mSPLDef.SPLD_MarketingSection.wXML_MarketingName
      szOutputLine = "         <" + szSectionName + ">"
      GenerateLine( mSPLDef, lFileHandle, szOutputLine )
      szIndentation = "            "
      szValue = mSPLDef.SPLD_MarketingSection.Title
      GenerateAttribute( mSPLDef, lFileHandle, "Title", szIndentation, szValue )
      // <SPLD_MarketingStatement>
      FOR EACH mSPLDef.SPLD_MarketingStatement
         szOutputLine = "            <SPLD_MarketingStatement>"
         GenerateLine( mSPLDef, lFileHandle, szOutputLine )
         szIndentation = "               "
         szValue = mSPLDef.SPLD_MarketingStatement.Title
         GenerateAttribute( mSPLDef, lFileHandle, "Title", szIndentation, szValue )
         szValue = mSPLDef.SPLD_MarketingStatement.wkDisplayText     // We'll use wkDisplayText because it includes inserted characters.
         GenerateAttribute( mSPLDef, lFileHandle, "Text", szIndentation, szValue )
         szOutputLine = "            </SPLD_MarketingStatement>"
         GenerateLine( mSPLDef, lFileHandle, szOutputLine )
      END
      // <SPLD_DirectionsUsageOrdering>
      FOR EACH mSPLDef.SPLD_DirectionsUsageOrdering
         szOutputLine = "         <SPLD_DirectionsUsageOrdering>"
         GenerateLine( mSPLDef, lFileHandle, szOutputLine )
         szIndentation = "               "
         szValue = mSPLDef.SPLD_DirectionsUsageOrdering.wSortOrder
         GenerateAttribute( mSPLDef, lFileHandle, "wSortOrder", szIndentation, szValue )
         // <SPLD_DirectionsUsageOrdering>
         szOutputLine = "            <SPLD_DirectionsUsage>"
         GenerateLine( mSPLDef, lFileHandle, szOutputLine )
         szIndentation = "               "
         szValue = mSPLDef.SPLD_DirectionsUsage.UsageType
         GenerateAttribute( mSPLDef, lFileHandle, "UsageType", szIndentation, szValue )
         szValue = mSPLDef.SPLD_DirectionsUsage.Name
         GenerateAttribute( mSPLDef, lFileHandle, "Name", szIndentation, szValue )
         szOutputLine = "            </SPLD_DirectionsUsage>"
         GenerateLine( mSPLDef, lFileHandle, szOutputLine )
         szOutputLine = "         </SPLD_DirectionsUsageOrdering>"
         GenerateLine( mSPLDef, lFileHandle, szOutputLine )
      END
      // <DisplayUsageColumn1>
      FOR EACH mSPLDef.DisplayUsageColumn1
         szOutputLine = "            <DisplayUsageColumn1>"
         GenerateLine( mSPLDef, lFileHandle, szOutputLine )
         szIndentation = "               "
         szValue = mSPLDef.DisplayUsageColumn1.Name
         GenerateAttribute( mSPLDef, lFileHandle, "Name", szIndentation, szValue )
         szOutputLine = "            </DisplayUsageColumn1>"
         GenerateLine( mSPLDef, lFileHandle, szOutputLine )
      END
      // <DisplayUsageColumn2>
      FOR EACH mSPLDef.DisplayUsageColumn2
         szOutputLine = "            <DisplayUsageColumn2>"
         GenerateLine( mSPLDef, lFileHandle, szOutputLine )
         szIndentation = "               "
         szValue = mSPLDef.DisplayUsageColumn2.Name
         GenerateAttribute( mSPLDef, lFileHandle, "Name", szIndentation, szValue )
         szOutputLine = "            </DisplayUsageColumn2>"
         GenerateLine( mSPLDef, lFileHandle, szOutputLine )
      END
      // <DisplayUsageColumn3>
      FOR EACH mSPLDef.DisplayUsageColumn3
         szOutputLine = "            <DisplayUsageColumn3>"
         GenerateLine( mSPLDef, lFileHandle, szOutputLine )
         szIndentation = "               "
         szValue = mSPLDef.DisplayUsageColumn3.Name
         GenerateAttribute( mSPLDef, lFileHandle, "Name", szIndentation, szValue )
         szOutputLine = "            </DisplayUsageColumn3>"
         GenerateLine( mSPLDef, lFileHandle, szOutputLine )
      END
      szOutputLine = "         </" + szSectionName + ">"
      GenerateLine( mSPLDef, lFileHandle, szOutputLine )
   END*/

   // <DisplaySection>
   FOR EACH mSPLDef.DisplaySection
      szSectionName = mSPLDef.DisplaySection.XML_SectionName
      szOutputLine = "         <" + szSectionName + ">"
      GenerateLine( mSPLDef, lFileHandle, szOutputLine )
      szIndentation = "            "
      szValue = mSPLDef.DisplaySection.Title
      GenerateAttribute( mSPLDef, lFileHandle, "Title", szIndentation, szValue )

      // <DisplayStatement>
      FOR EACH mSPLDef.DisplayStatement
         szStatementName = mSPLDef.DisplayStatement.XML_StatementName
         szOutputLine = "            <" + szStatementName + ">"
         GenerateLine( mSPLDef, lFileHandle, szOutputLine )
         szIndentation = "               "
         szValue = mSPLDef.DisplayStatement.Title
         GenerateAttribute( mSPLDef, lFileHandle, "Title", szIndentation, szValue )
         szValue = mSPLDef.DisplayStatement.Text
         GenerateAttribute( mSPLDef, lFileHandle, "Text", szIndentation, szValue )
         szStatementName = mSPLDef.DisplayStatement.XML_StatementName
         szOutputLine = "            </" + szStatementName + ">"
         GenerateLine( mSPLDef, lFileHandle, szOutputLine )
      END

      // <DisplayUsageColumn1>
      FOR EACH mSPLDef.DisplayUsageColumn1
         szOutputLine = "            <DisplayUsageColumn1>"
         GenerateLine( mSPLDef, lFileHandle, szOutputLine )
         szIndentation = "               "
         szValue = mSPLDef.DisplayUsageColumn1.Name
         GenerateAttribute( mSPLDef, lFileHandle, "Name", szIndentation, szValue )
         szOutputLine = "            </DisplayUsageColumn1>"
         GenerateLine( mSPLDef, lFileHandle, szOutputLine )
      END

      // <DisplayUsageColumn2>
      FOR EACH mSPLDef.DisplayUsageColumn2
         szOutputLine = "            <DisplayUsageColumn2>"
         GenerateLine( mSPLDef, lFileHandle, szOutputLine )
         szIndentation = "               "
         szValue = mSPLDef.DisplayUsageColumn2.Name
         GenerateAttribute( mSPLDef, lFileHandle, "Name", szIndentation, szValue )
         szOutputLine = "            </DisplayUsageColumn2>"
         GenerateLine( mSPLDef, lFileHandle, szOutputLine )
      END

      // <DisplayUsageColumn3>
      FOR EACH mSPLDef.DisplayUsageColumn3
         szOutputLine = "            <DisplayUsageColumn3>"
         GenerateLine( mSPLDef, lFileHandle, szOutputLine )
         szIndentation = "               "
         szValue = mSPLDef.DisplayUsageColumn3.Name
         GenerateAttribute( mSPLDef, lFileHandle, "Name", szIndentation, szValue )
         szOutputLine = "            </DisplayUsageColumn3>"
         GenerateLine( mSPLDef, lFileHandle, szOutputLine )
      END

      szOutputLine = "         </" + szSectionName + ">"
      GenerateLine( mSPLDef, lFileHandle, szOutputLine )
   END

   // <SPLD_HumanHazardSection>
   FOR EACH mSPLDef.SPLD_HumanHazardSection
      szOutputLine = "         <SPLD_HumanHazardSection>"
      GenerateLine( mSPLDef, lFileHandle, szOutputLine )
      szIndentation = "            "
      szValue = mSPLDef.SPLD_HumanHazardSection.EPA_SignalWord
      GenerateAttribute( mSPLDef, lFileHandle, "EPA_SignalWord", szIndentation, szValue )
      szValue = mSPLDef.SPLD_HumanHazardSection.EPA_ChildHazardWarning
      GenerateAttribute( mSPLDef, lFileHandle, "EPA_ChildHazardWarning", szIndentation, szValue )
      szValue = mSPLDef.SPLD_HumanHazardSection.PrecautionaryStatement
      GenerateAttribute( mSPLDef, lFileHandle, "PrecautionaryStatement", szIndentation, szValue )
      szOutputLine = "         </SPLD_HumanHazardSection>"
      GenerateLine( mSPLDef, lFileHandle, szOutputLine )
   END

   // Build Footer entries.
   szOutputLine = "      </SubregPhysicalLabelDef>"
   GenerateLine( mSPLDef, lFileHandle, szOutputLine )
   szOutputLine = "   </zOI>"
   GenerateLine( mSPLDef, lFileHandle, szOutputLine )

   // Close the XML file.
   SysCloseFile( mSPLDef, lFileHandle, 0 )

END

/////////////////////////////////////////////////////////////////////////////
//
//  OPERATION: GenerateLine
//
//    This is just a SysWriteLine with an options TraceLineS statement.
//
/////////////////////////////////////////////////////////////////////////////
LOCAL OPERATION
GenerateLine( VIEW mSPLDef BASED ON LOD mSPLDef,
              INTEGER lFileHandle,
              STRING ( 5000 ) szOutputLine )

   SHORT nRC

   nRC = zSearchSubString( szOutputLine, "at a temperature of", "f", 1 )
   IF nRC >= 0   
      TraceLineS( "*** Line Before ConvertHtmlEntities: ", szOutputLine )
   END
   ConvertHtmlEntities( szOutputLine )
   IF nRC >= 0   
      TraceLineS( "*** Line After ConvertHtmlEntities: ", szOutputLine )
   END
   SysWriteLine( mSPLDef, lFileHandle, szOutputLine )

END

/////////////////////////////////////////////////////////////////////////////
//
//  OPERATION: GenerateLine
//
/////////////////////////////////////////////////////////////////////////////
LOCAL OPERATION
GenerateAttribute( VIEW mSPLDef BASED ON LOD mSPLDef,
                   INTEGER lFileHandle,
                   STRING ( 32 )   szAttributeName,
                   STRING ( 50 )   szLeadingBlanks,
                   STRING ( 5000 ) szValue )

   STRING ( 5000 ) szOutputLine

   // Format an XML line for an attribute value.
   szOutputLine = szLeadingBlanks + "<" + szAttributeName + ">" + szValue + "</" + szAttributeName + ">"
   GenerateLine( mSPLDef, lFileHandle, szOutputLine )

END

/////////////////////////////////////////////////////////////////////////////
//
//  OPERATION: ComputeTopPosRecursive
//
/////////////////////////////////////////////////////////////////////////////
TRANSFORMATION OPERATION
ComputeTopPosRecursive( VIEW mSPLDef BASED ON LOD mSPLDef )

   DECIMAL LastBlockTopPosition

   LastBlockTopPosition = 0
   FOR EACH mSPLDef.LLD_Block
      IF mSPLDef.LLD_Block.Top != ""
         mSPLDef.LLD_Block.wComputedTopPosition = mSPLDef.LLD_Block.Top
         LastBlockTopPosition = mSPLDef.LLD_Block.Top + mSPLDef.LLD_Block.Height
      ELSE
         mSPLDef.LLD_Block.wComputedTopPosition = LastBlockTopPosition
         LastBlockTopPosition = LastBlockTopPosition + mSPLDef.LLD_Block.Height
      END
      FOR EACH mSPLDef.LLD_SubBlock
         SetViewToSubobject( mSPLDef, "LLD_SubBlock" )
         ComputeTopPosRecursive( mSPLDef )
         ResetViewFromSubobject( mSPLDef )
      END
   END
END

/////////////////////////////////////////////////////////////////////////////
//
//  OPERATION: ComputeTopPositions
//
/////////////////////////////////////////////////////////////////////////////
TRANSFORMATION OPERATION
ComputeTopPositions( VIEW mSPLDef BASED ON LOD mSPLDef )

   // Calculate the Top position for each Block and SubBlock. SubBlock positions are relative
   // to the parent Block.
   // If the Top Position is specified, we'll use it. Otherwise, we'll use the last position of the
   // previous Block or SubBlock entry plus its Height.
// FOR EACH mSPLDef.LLD_Page WITHIN mSPLDef.SubregPhysicalLabelDef
   FOR EACH mSPLDef.LLD_Page  // only do it within the current SPLD_LLD
      FOR EACH mSPLDef.LLD_Panel
         ComputeTopPosRecursive( mSPLDef )
      END
   END
END

/////////////////////////////////////////////////////////////////////////////
//
//  OPERATION: TraverseBlockRecursive
//
/////////////////////////////////////////////////////////////////////////////
TRANSFORMATION OPERATION
TraverseBlockRecursive( VIEW mSPLDef BASED ON LOD mSPLDef )

   FOR EACH mSPLDef.LLD_Block
      mSPLDef.LLD_Block.wContinuedFromTag = ""
      FOR EACH mSPLDef.LLD_SubBlock
         SetViewToSubobject( mSPLDef, "LLD_SubBlock" )
         TraverseBlockRecursive( mSPLDef )
         ResetViewFromSubobject( mSPLDef )
      END
   END
END

/////////////////////////////////////////////////////////////////////////////
//
//  OPERATION: TraverseBlocks
//  Reset the wContinuedFromTag
//
/////////////////////////////////////////////////////////////////////////////
TRANSFORMATION OPERATION
TraverseBlocks( VIEW mSPLDef BASED ON LOD mSPLDef )

// FOR EACH mSPLDef.LLD_Page WITHIN mSPLDef.SubregPhysicalLabelDef
   FOR EACH mSPLDef.LLD_Page  // only do it within the current SPLD_LLD
      FOR EACH mSPLDef.LLD_Panel
         TraverseBlockRecursive( mSPLDef )
         OrderEntityForView( mSPLDef, "LLD_Block", "Left A wComputedTopPosition A" )  // ContinuationBlockFlag D
      END
   END
END

/////////////////////////////////////////////////////////////////////////////
//
//  OPERATION: ObjectConstraints
//
/////////////////////////////////////////////////////////////////////////////
OBJECT CONSTRAINT OPERATION
ObjectConstraints( VIEW mSPLDef BASED ON LOD mSPLDef,
                   SHORT Event,
                   SHORT State )

   CASE Event
   OF   zOCE_ACTIVATE:

   // Compute work position entries for SubBlocks and put them in position order.
   ComputeTopPositions( mSPLDef )
   FOR EACH mSPLDef.LLD_Page
      FOR EACH mSPLDef.LLD_Panel
         FOR EACH mSPLDef.LLD_Block
            OrderEntityForView( mSPLDef, "LLD_SubBlock", "wComputedTopPosition A" )
         END
      END
   END
   SET CURSOR FIRST mSPLDef.LLD_Page

   // Make sure the new SPLD_UsageType subobject structure is used.
   IF mSPLDef.SPLD_UsageType DOES NOT EXIST
      FOR EACH mSPLDef.SPLD_UsageDelete
         SET CURSOR FIRST mSPLDef.SPLD_UsageType WHERE mSPLDef.SPLD_UsageType.UsageType = mSPLDef.SPLD_UsageDelete.UsageType
         IF RESULT < zCURSOR_SET
            CREATE ENTITY mSPLDef.SPLD_UsageType
            mSPLDef.SPLD_UsageType.UsageType = mSPLDef.SPLD_UsageDelete.UsageType
         END
         CREATE ENTITY mSPLDef.SPLD_Usage
         SetMatchingAttributesByName( mSPLDef, "SPLD_Usage", mSPLDef, "SPLD_UsageDelete", zSET_NULL )
         INCLUDE mSPLDef.S_Usage FROM mSPLDef.S_UsageDelete
      END
   END

        // end zOCE_ACTIVATE
   OF   zOCE_ACTIVATE_EMPTY:

        // end zOCE_ACTIVATE_EMPTY
   OF   zOCE_COMMIT:

        // end zOCE_COMMIT
   OF   zOCE_DROPOI:

        // end zOCE_DROPOI
   END  // case

END

/////////////////////////////////////////////////////////////////////////////
//
//  OPERATION: CheckAddKeywordEntry
//
/////////////////////////////////////////////////////////////////////////////
TRANSFORMATION OPERATION
CheckAddKeywordEntry( VIEW mSPLDefBlock BASED ON LOD mSPLDef,
                      STRING ( 50 ) szSectionType,
                      STRING ( 50 ) szKeywordName )

   // Make sure that the entry for the SectionType passed in exists.
   SET CURSOR FIRST mSPLDefBlock.LLD_SpecialSectionAttribute WHERE mSPLDefBlock.LLD_SpecialSectionAttribute.Name = szSectionType
   IF RESULT < zCURSOR_SET
   // TraceLineS( "CheckAddKeyordEntry adding SpecialSectionAttribute: ", szSectionType )
      SET CURSOR LAST mSPLDefBlock.LLD_SpecialSectionAttribute
      CREATE ENTITY mSPLDefBlock.LLD_SpecialSectionAttribute
      mSPLDefBlock.LLD_SpecialSectionAttribute.Name = szSectionType
   ELSE
   // TraceLineS( "CheckAddKeyordEntry located SpecialSectionAttribute: ", szSectionType )
   END   

   // Make sure that the entry for the Keyword passed in exists.
   SET CURSOR FIRST mSPLDefBlock.LLD_SpecialSectionAttrBlock WHERE mSPLDefBlock.LLD_SpecialSectionAttrBlock.Name = szKeywordName
   IF RESULT < zCURSOR_SET
   // TraceLineS( "CheckAddKeyordEntry adding SpecialSectionAttrBlock: ", szKeywordName )
      SET CURSOR LAST mSPLDefBlock.LLD_SpecialSectionAttrBlock
      CREATE ENTITY mSPLDefBlock.LLD_SpecialSectionAttrBlock
      mSPLDefBlock.LLD_SpecialSectionAttrBlock.Name = szKeywordName
   ELSE
   // TraceLineS( "CheckAddKeyordEntry located SpecialSectionAttrBlock: ", szKeywordName )
   END

END

/*
/////////////////////////////////////////////////////////////////////////////
//  No longer used ... incorrectly deletes everything up front.  Replaced by SetUpKeywordEntries.
//
//  OPERATION: SetUpFormattingSelect
//
TRANSFORMATION OPERATION
SetUpFormattingSelect( VIEW mSPLDefPanel BASED ON LOD mSPLDef,
                       STRING ( 50 ) szSectionType )
   // Initialize the SpecialFormattingSelectEntry entries depending on Section Type.
   FOR EACH mSPLDefPanel.SpecialFormattingSelectEntry
      DELETE ENTITY mSPLDefPanel.SpecialFormattingSelectEntry NONE
   END
   IF szSectionType = "HumanHazard"
      // Human Hazard
      CREATE ENTITY mSPLDefPanel.SpecialFormattingSelectEntry
      mSPLDefPanel.SpecialFormattingSelectEntry.KeywordName = "Hazards Warning"
      CREATE ENTITY mSPLDefPanel.SpecialFormattingSelectEntry
      mSPLDefPanel.SpecialFormattingSelectEntry.KeywordName = "Hazards Signal Word"
      CREATE ENTITY mSPLDefPanel.SpecialFormattingSelectEntry
      mSPLDefPanel.SpecialFormattingSelectEntry.KeywordName = "Hazards Precautionary"
   ELSE
   IF szSectionType = "Ingredients"
      // Ingredients
      CREATE ENTITY mSPLDefPanel.SpecialFormattingSelectEntry
      mSPLDefPanel.SpecialFormattingSelectEntry.KeywordName = "Ingredients Title"
      CREATE ENTITY mSPLDefPanel.SpecialFormattingSelectEntry
      mSPLDefPanel.SpecialFormattingSelectEntry.KeywordName = "Ingredients Items"
      CREATE ENTITY mSPLDefPanel.SpecialFormattingSelectEntry
      mSPLDefPanel.SpecialFormattingSelectEntry.KeywordName = "Ingredients Inert"
      CREATE ENTITY mSPLDefPanel.SpecialFormattingSelectEntry
      mSPLDefPanel.SpecialFormattingSelectEntry.KeywordName = "Ingredients Total"
   ELSE
   IF szSectionType = "DirectionsForUse" OR szSectionType = "FirstAid"
      // Directions For Use or First Aid
      CREATE ENTITY mSPLDefPanel.SpecialFormattingSelectEntry
      mSPLDefPanel.SpecialFormattingSelectEntry.KeywordName = "Header"
      CREATE ENTITY mSPLDefPanel.SpecialFormattingSelectEntry
      mSPLDefPanel.SpecialFormattingSelectEntry.KeywordName = "Title"
      CREATE ENTITY mSPLDefPanel.SpecialFormattingSelectEntry
      mSPLDefPanel.SpecialFormattingSelectEntry.KeywordName = "Text"
   ELSE
   IF szSectionType = "Marketing"
      // Marketing
      CREATE ENTITY mSPLDefPanel.SpecialFormattingSelectEntry
      mSPLDefPanel.SpecialFormattingSelectEntry.KeywordName = "Title"
      CREATE ENTITY mSPLDefPanel.SpecialFormattingSelectEntry
      mSPLDefPanel.SpecialFormattingSelectEntry.KeywordName = "Text"
      CREATE ENTITY mSPLDefPanel.SpecialFormattingSelectEntry
      mSPLDefPanel.SpecialFormattingSelectEntry.KeywordName = "Column List"
   ELSE
      // Default
      IF szSectionType != "NetContents" AND szSectionType != "EPA_RegAndEstNbr"
         CREATE ENTITY mSPLDefPanel.SpecialFormattingSelectEntry
         mSPLDefPanel.SpecialFormattingSelectEntry.KeywordName = "Title"
      END
      CREATE ENTITY mSPLDefPanel.SpecialFormattingSelectEntry
      mSPLDefPanel.SpecialFormattingSelectEntry.KeywordName = "Text"
   END
   END
   END
   END
   CREATE ENTITY mSPLDefPanel.SpecialFormattingSelectEntry
   mSPLDefPanel.SpecialFormattingSelectEntry.KeywordName = "Block"
   SET CURSOR FIRST mSPLDefPanel.SpecialFormattingSelectEntry
END
/////////////////////////////////////////////////////////////////////////////
*/

/////////////////////////////////////////////////////////////////////////////
//
//  OPERATION: SetUpKeywordEntries
//
/////////////////////////////////////////////////////////////////////////////
TRANSFORMATION OPERATION
SetUpKeywordEntries( VIEW mSPLDefBlock BASED ON LOD mSPLDef,
                     STRING ( 50 ) szSectionType )

   // Make sure that the appropriate Keyword entries are set up for a given Section/Block Type.
   IF szSectionType = "Marketing"
      // Marketing
      CheckAddKeywordEntry( mSPLDefBlock, szSectionType, "Title" )
      CheckAddKeywordEntry( mSPLDefBlock, szSectionType, "Text" )
      CheckAddKeywordEntry( mSPLDefBlock, szSectionType, "Column List" )
   ELSE
   IF szSectionType = "HumanHazard"
      // Human Hazard
      CheckAddKeywordEntry( mSPLDefBlock, szSectionType, "Hazards Warning" )
      CheckAddKeywordEntry( mSPLDefBlock, szSectionType, "Hazards Signal Word" )
      CheckAddKeywordEntry( mSPLDefBlock, szSectionType, "Hazards Precautionary" )
   ELSE
   IF szSectionType = "Ingredients"
      // Ingredients
      CheckAddKeywordEntry( mSPLDefBlock, szSectionType, "Ingredients Title" )
      CheckAddKeywordEntry( mSPLDefBlock, szSectionType, "Ingredients Items" )
      CheckAddKeywordEntry( mSPLDefBlock, szSectionType, "Ingredients Inert" )
      CheckAddKeywordEntry( mSPLDefBlock, szSectionType, "Ingredients Total" )
   ELSE
   IF szSectionType = "DirectionsForUse" OR szSectionType = "FirstAid"
      // Directions For Use or First Aid
      CheckAddKeywordEntry( mSPLDefBlock, szSectionType, "Header" )
      CheckAddKeywordEntry( mSPLDefBlock, szSectionType, "Title" )
      CheckAddKeywordEntry( mSPLDefBlock, szSectionType, "Text" )
   ELSE
      // Default
      CheckAddKeywordEntry( mSPLDefBlock, szSectionType, "Title" )
      CheckAddKeywordEntry( mSPLDefBlock, szSectionType, "Text" )
   END
   END
   END
   END

END

/////////////////////////////////////////////////////////////////////////////
//
//  OPERATION: dColorName
//
/////////////////////////////////////////////////////////////////////////////
DERIVED ATTRIBUTE OPERATION
dColorName( VIEW mSPLDef BASED ON LOD mSPLDef,
            STRING ( 32 ) InternalEntityStructure,
            STRING ( 32 ) InternalAttribStructure,
            SHORT GetOrSetFlag )

   STRING ( 32 ) szName

   CASE GetOrSetFlag
   OF   zDERIVED_GET:

       GetStringFromAttribute( szName, mSPLDef, InternalEntityStructure, "Pantone" )
       IF szName = ""
          GetStringFromAttribute( szName, mSPLDef, InternalEntityStructure, "Name" )
       END
       // Store the calculated value in the object.
       StoreStringInRecord( mSPLDef, InternalEntityStructure, InternalAttribStructure, szName )
       RETURN 0

        // end zDERIVED_GET
   OF   zDERIVED_SET:

        // end zDERIVED_SET
   END  // case

END

/////////////////////////////////////////////////////////////////////////////
//
//  OPERATION: dCombinedContainerVol
//
/////////////////////////////////////////////////////////////////////////////
DERIVED ATTRIBUTE OPERATION
dCombinedContainerVol( VIEW mSPLDef BASED ON LOD mSPLDef,
                       STRING ( 32 ) InternalEntityStructure,
                       STRING ( 32 ) InternalAttribStructure,
                       SHORT GetOrSetFlag )

   STRING ( 256 ) szCombinedName
   STRING ( 20 )  szContainerVolume

   CASE GetOrSetFlag
   OF   zDERIVED_GET:

      // Combine each volume name that drives this section.
      szCombinedName = "???"
/*    FOR EACH mSPLDef.SPLD_StorageDisposalDrivingConVol
  ???         GetStringFromAttributeByContext( szContainerVolume, mSPLDef, "SPLD_StorageDisposalDrivingConVol", "ContainerVolume", "", 20 )
         IF szCombinedName = ""
            szCombinedName = szContainerVolume
         ELSE
            szCombinedName = szCombinedName + ", " + szContainerVolume
         END
      END
*/

      // Store the calculated value in the object.
      StoreStringInRecord( mSPLDef, InternalEntityStructure, InternalAttribStructure, szCombinedName )
      RETURN 0

        // end zDERIVED_GET
   OF   zDERIVED_SET:

        // end zDERIVED_SET
   END  // case

END

/////////////////////////////////////////////////////////////////////////////
//
//  OPERATION: dSD_TitleText
//
/////////////////////////////////////////////////////////////////////////////
DERIVED ATTRIBUTE OPERATION
dSD_TitleText( VIEW mSPLDef BASED ON LOD mSPLDef,
               STRING ( 32 ) InternalEntityStructure,
               STRING ( 32 ) InternalAttribStructure,
               SHORT GetOrSetFlag )

   STRING ( 2048 ) szDisplayStatement
   STRING ( 2048 ) szStatementText
   STRING ( 256 )  szTitle

   CASE GetOrSetFlag
   OF   zDERIVED_GET:

      // Storage and Disposal Display Statement Text is a combination of Title and Text.
      szTitle = mSPLDef.SPLD_StorageDisposalStatement.Title
      szStatementText = mSPLDef.SPLD_StorageDisposalStatement.Text
      IF szTitle != ""
         szDisplayStatement = szTitle + " --- " + szStatementText
      ELSE
         szDisplayStatement = szStatementText
      END


      // Store the calculated value in the object.
      StoreStringInRecord( mSPLDef, InternalEntityStructure, InternalAttribStructure, szDisplayStatement )
      RETURN 0

        // end zDERIVED_GET
   OF   zDERIVED_SET:

        // end zDERIVED_SET
   END  // case

END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  OPERATION: dSD_StmtTitleKey
//
/////////////////////////////////////////////////////////////////////////////
DERIVED ATTRIBUTE OPERATION
dSD_StmtTitleKey( VIEW mSPLDef BASED ON LOD mSPLDef,
                  STRING ( 32 ) InternalEntityStructure,
                  STRING ( 32 ) InternalAttribStructure,
                  SHORT GetOrSetFlag )

   STRING ( 2048 ) szStatementTitle

   CASE GetOrSetFlag
   OF   zDERIVED_GET:

      // Storage and Disposal Display Statement Title is a combination of Title/Keywords.
      szStatementTitle = mSPLDef.SPLD_StorageDisposalStatement.Title
      IF szStatementTitle != ""
         GenerateKeywordTextIntoString( mSPLDef, szStatementTitle,
                                        "SPLD_InsertTextKeywordSD", "SPLD_InsertTextSD", ", " )
      END

      // Store the calculated value in the object.
      StoreStringInRecord( mSPLDef, InternalEntityStructure, InternalAttribStructure, szStatementTitle )

        // end zDERIVED_GET
   OF   zDERIVED_SET:

        // end zDERIVED_SET
   END  // case

END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  OPERATION: dSD_StmtTextKey
//
/////////////////////////////////////////////////////////////////////////////
DERIVED ATTRIBUTE OPERATION
dSD_StmtTextKey( VIEW mSPLDef BASED ON LOD mSPLDef,
                 STRING ( 32 ) InternalEntityStructure,
                 STRING ( 32 ) InternalAttribStructure,
                 SHORT GetOrSetFlag )

   STRING ( 2048 ) szStatementText

   CASE GetOrSetFlag
   OF   zDERIVED_GET:

      // Storage and Disposal Display Statement Text is a combination of Text/Keywords.
      szStatementText = mSPLDef.SPLD_StorageDisposalStatement.Text
      IF szStatementText != ""
         GenerateKeywordTextIntoString( mSPLDef, szStatementText,
                                        "SPLD_InsertTextKeywordSD", "SPLD_InsertTextSD", ", " )
      END

      // Store the calculated value in the object.
      StoreStringInRecord( mSPLDef, InternalEntityStructure, InternalAttribStructure, szStatementText )

        // end zDERIVED_GET
   OF   zDERIVED_SET:

        // end zDERIVED_SET
   END  // case

END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  OPERATION: dSD_StmtTitleTxtKey
//
/////////////////////////////////////////////////////////////////////////////
DERIVED ATTRIBUTE OPERATION
dSD_StmtTitleTxtKey( VIEW mSPLDef BASED ON LOD mSPLDef,
                     STRING ( 32 ) InternalEntityStructure,
                     STRING ( 32 ) InternalAttribStructure,
                     SHORT GetOrSetFlag )

   STRING ( 2048 ) szDisplayStatement
   STRING ( 256 )  szStatementTitle
   STRING ( 2048 ) szStatementText

   CASE GetOrSetFlag
   OF   zDERIVED_GET:

      // Storage and Disposal Display Statement Text is a combination of Title/Text/Keywords.
      szStatementText = mSPLDef.SPLD_StorageDisposalStatement.Text
      IF szStatementText != ""
         GenerateKeywordTextIntoString( mSPLDef, szStatementText,
                                        "SPLD_InsertTextKeywordSD", "SPLD_InsertTextSD", ", " )
      END

      szStatementTitle = mSPLDef.SPLD_StorageDisposalStatement.Title
      IF szStatementTitle != ""
         GenerateKeywordTextIntoString( mSPLDef, szStatementTitle,
                                        "SPLD_InsertTextKeywordSD", "SPLD_InsertTextSD", ", " )
         szDisplayStatement = szStatementTitle
         IF szStatementText != ""
            szDisplayStatement = szDisplayStatement + " --- " + szStatementText
         END
      ELSE
         szDisplayStatement = szStatementText
      END

      // Store the calculated value in the object.
      StoreStringInRecord( mSPLDef, InternalEntityStructure, InternalAttribStructure, szDisplayStatement )

        // end zDERIVED_GET
   OF   zDERIVED_SET:

        // end zDERIVED_SET
   END  // case

END

DERIVED ATTRIBUTE OPERATION
dSD_KeywordText( VIEW mSPLDef BASED ON LOD mSPLDef,
                 STRING ( 32 ) InternalEntityStructure,
                 STRING ( 32 ) InternalAttribStructure,
                 SHORT GetOrSetFlag )

   STRING ( 2048 ) szGeneratedString

   CASE GetOrSetFlag
   OF   zDERIVED_GET:

      // Concatenate all the Keyword values for a Storage & Disposal Keyword entry.
      szGeneratedString = ""
      FOR EACH mSPLDef.SPLD_InsertTextSD
         IF szGeneratedString = ""
            szGeneratedString = mSPLDef.SPLD_InsertTextSD.Text
         ELSE
            szGeneratedString = szGeneratedString + ", " + mSPLDef.SPLD_InsertTextSD.Text
         END
      END

      // Store the resulting value in the object.
      StoreStringInRecord( mSPLDef, InternalEntityStructure, InternalAttribStructure, szGeneratedString )
      RETURN 0

        // end zDERIVED_GET
   OF   zDERIVED_SET:

        // end zDERIVED_SET
   END  // case

END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  OPERATION: dSD_SubStmtTitleTxtKey
//
/////////////////////////////////////////////////////////////////////////////
DERIVED ATTRIBUTE OPERATION
dSD_SubStmtTitleTxtKey( VIEW mSPLDef BASED ON LOD mSPLDef,
                        STRING ( 32 ) InternalEntityStructure,
                        STRING ( 32 ) InternalAttribStructure,
                        SHORT GetOrSetFlag )

   STRING ( 2048 ) szDisplayStatement
   STRING ( 256 )  szStatementTitle
   STRING ( 2048 ) szStatementText

   CASE GetOrSetFlag
   OF   zDERIVED_GET:

      // Storage and Disposal Display Statement Text is a combination of Title/Text/Keywords.
      SetViewToSubobject( mSPLDef, "SPLD_StorageDisposalSubStmt" )
      szStatementText = mSPLDef.SPLD_StorageDisposalStatement.Text
      IF szStatementText != ""
         GenerateKeywordTextIntoString( mSPLDef, szStatementText,
                                        "SPLD_InsertTextKeywordSD", "SPLD_InsertTextSD", ", " )
      END

      szStatementTitle = mSPLDef.SPLD_StorageDisposalStatement.Title
      IF szStatementTitle != ""
         GenerateKeywordTextIntoString( mSPLDef, szStatementTitle,
                                        "SPLD_InsertTextKeywordSD", "SPLD_InsertTextSD", ", " )
      END

      IF szStatementTitle != ""
         szDisplayStatement = szStatementTitle
         IF szStatementText != ""
            szDisplayStatement = szDisplayStatement + " --- " + szStatementText
         END
      ELSE
         szDisplayStatement = szStatementText
      END

      ResetViewFromSubobject( mSPLDef )
      
      // Store the calculated value in the object.
      StoreStringInRecord( mSPLDef, InternalEntityStructure, InternalAttribStructure, szDisplayStatement )

        // end zDERIVED_GET
   OF   zDERIVED_SET:

        // end zDERIVED_SET
   END  // case

END

/////////////////////////////////////////////////////////////////////////////
//
//  OPERATION: dSD_SubTitleText
//
/////////////////////////////////////////////////////////////////////////////
DERIVED ATTRIBUTE OPERATION
dSD_SubTitleText( VIEW mSPLDef BASED ON LOD mSPLDef,
                  STRING ( 32 ) InternalEntityStructure,
                  STRING ( 32 ) InternalAttribStructure,
                  SHORT GetOrSetFlag )

   STRING ( 2048 ) szDisplayStatement
   STRING ( 2048 ) szStatementText
   STRING ( 256 )  szTitle

   CASE GetOrSetFlag
   OF   zDERIVED_GET:

      // Storage and Disposal Display Statement Text is a combination of Title and Text.
      szTitle = mSPLDef.SPLD_StorageDisposalSubStmt.Title
      szStatementText = mSPLDef.SPLD_StorageDisposalSubStmt.Text
      IF szTitle != ""
         szDisplayStatement = szTitle + " --- " + szStatementText
      ELSE
         szDisplayStatement = szStatementText
      END


      // Store the calculated value in the object.
      StoreStringInRecord( mSPLDef, InternalEntityStructure, InternalAttribStructure, szDisplayStatement )
      RETURN 0

        // end zDERIVED_GET
   OF   zDERIVED_SET:

        // end zDERIVED_SET
   END  // case

END

/////////////////////////////////////////////////////////////////////////////
//
//  OPERATION: dDU_KeywordText
//
/////////////////////////////////////////////////////////////////////////////
DERIVED ATTRIBUTE OPERATION
dDU_KeywordText( VIEW mSPLDef BASED ON LOD mSPLDef,
                 STRING ( 32 ) InternalEntityStructure,
                 STRING ( 32 ) InternalAttribStructure,
                 SHORT GetOrSetFlag )

   STRING ( 2048 ) szKeyValue

   CASE GetOrSetFlag
   OF   zDERIVED_GET:

      // Concatenate all the Keyword values for a Directions For Use Keyword entry.
      szKeyValue = ""
      FOR EACH mSPLDef.SPLD_InsertTextDU
         IF szKeyValue = ""
            szKeyValue = mSPLDef.SPLD_InsertTextDU.Text
         ELSE
            szKeyValue = szKeyValue + ", " + mSPLDef.SPLD_InsertTextDU.Text
         END
      END

      // Store the resulting value in the object.
      StoreStringInRecord( mSPLDef, InternalEntityStructure, InternalAttribStructure, szKeyValue )
      RETURN 0

        // end zDERIVED_GET
   OF   zDERIVED_SET:

        // end zDERIVED_SET
   END  // case

END

/////////////////////////////////////////////////////////////////////////////
//
//  OPERATION: dDU_StmtTitleTxtKey
//
/////////////////////////////////////////////////////////////////////////////
DERIVED ATTRIBUTE OPERATION
dDU_StmtTitleTxtKey( VIEW mSPLDef BASED ON LOD mSPLDef,
                     STRING ( 32 ) InternalEntityStructure,
                     STRING ( 32 ) InternalAttribStructure,
                     SHORT GetOrSetFlag )

   STRING ( 2048 ) szDisplayStatement
   STRING ( 256 )  szStatementTitle
   STRING ( 2048 ) szStatementText

   CASE GetOrSetFlag
   OF   zDERIVED_GET:

      // Directions For Use Display Statement Text is a combination of Title/Text/Keywords.
      szStatementText = mSPLDef.SPLD_DirectionsForUseStatement.Text
      IF szStatementText != ""
         GenerateKeywordTextIntoString( mSPLDef, szStatementText,
                                        "SPLD_InsertTextKeywordDU", "SPLD_InsertTextDU", ", " )
      END

      szStatementTitle = mSPLDef.SPLD_DirectionsForUseStatement.Title
      IF szStatementTitle != ""
         GenerateKeywordTextIntoString( mSPLDef, szStatementTitle,
                                        "SPLD_InsertTextKeywordDU", "SPLD_InsertTextDU", ", " )
      END

      IF szStatementTitle != ""
         szDisplayStatement = szStatementTitle
         IF szStatementText != ""
            szDisplayStatement = szDisplayStatement + " --- " + szStatementText
         END
      ELSE
         szDisplayStatement = szStatementText
      END

      // Store the calculated value in the object.
      StoreStringInRecord( mSPLDef, InternalEntityStructure, InternalAttribStructure, szDisplayStatement )

        // end zDERIVED_GET
   OF   zDERIVED_SET:

        // end zDERIVED_SET
   END  // case

END

/////////////////////////////////////////////////////////////////////////////
//
//  OPERATION: dDU_SubStmtTitleText
//
/////////////////////////////////////////////////////////////////////////////
DERIVED ATTRIBUTE OPERATION
dDU_SubStmtTitleText( VIEW mSPLDef BASED ON LOD mSPLDef,
                      STRING ( 32 ) InternalEntityStructure,
                      STRING ( 32 ) InternalAttribStructure,
                      SHORT GetOrSetFlag )

   STRING ( 2048 ) szDisplayStatement
   STRING ( 2048 ) szStatementText
   STRING ( 256 )  szTitle

   CASE GetOrSetFlag
   OF   zDERIVED_GET:

      // Directions For Use Display Statement Text is a combination of Title and Text.
      szTitle = mSPLDef.SPLD_DirectionsForUseSubStmt.Title
      szStatementText = mSPLDef.SPLD_DirectionsForUseSubStmt.Text
      IF szTitle != ""
         szDisplayStatement = szTitle + " --- " + szStatementText
      ELSE
         szDisplayStatement = szStatementText
      END

      // Store the calculated value in the object.
      StoreStringInRecord( mSPLDef, InternalEntityStructure, InternalAttribStructure, szDisplayStatement )
      RETURN 0

        // end zDERIVED_GET
   OF   zDERIVED_SET:

        // end zDERIVED_SET
   END  // case

END

/////////////////////////////////////////////////////////////////////////////
//
//  OPERATION: dDU_SubStmtTitleTxtKey
//
/////////////////////////////////////////////////////////////////////////////
DERIVED ATTRIBUTE OPERATION
dDU_SubStmtTitleTxtKey( VIEW mSPLDef BASED ON LOD mSPLDef,
                        STRING ( 32 ) InternalEntityStructure,
                        STRING ( 32 ) InternalAttribStructure,
                        SHORT GetOrSetFlag )

   STRING ( 2048 ) szDisplayStatement
   STRING ( 256 )  szStatementTitle
   STRING ( 2048 ) szStatementText

   CASE GetOrSetFlag
   OF   zDERIVED_GET:

      // Directions For Use Display Statement Text is a combination of Title/Text/Keywords.
      SetViewToSubobject( mSPLDef, "SPLD_DirectionsForUseSubStmt" )
      
      szStatementText = mSPLDef.SPLD_DirectionsForUseStatement.Text
      IF szStatementText != ""
         GenerateKeywordTextIntoString( mSPLDef, szStatementText,
                                        "SPLD_InsertTextKeywordDU", "SPLD_InsertTextDU", ", " )
      END

      szStatementTitle = mSPLDef.SPLD_DirectionsForUseStatement.Title
      IF szStatementTitle != ""
         GenerateKeywordTextIntoString( mSPLDef, szStatementTitle,
                                        "SPLD_InsertTextKeywordDU", "SPLD_InsertTextDU", ", " )
      END

      IF szStatementTitle != ""
         szDisplayStatement = szStatementTitle
         IF szStatementText != ""
            szDisplayStatement = szDisplayStatement + " --- " + szStatementText
         END
      ELSE
         szDisplayStatement = szStatementText
      END

      ResetViewFromSubobject( mSPLDef )

      // Store the calculated value in the object.
      StoreStringInRecord( mSPLDef, InternalEntityStructure, InternalAttribStructure, szDisplayStatement )

        // end zDERIVED_GET
   OF   zDERIVED_SET:

        // end zDERIVED_SET
   END  // case

END

/////////////////////////////////////////////////////////////////////////////
//
//  OPERATION: dDU_SectionTitleKeyword
//
/////////////////////////////////////////////////////////////////////////////
DERIVED ATTRIBUTE OPERATION
dDU_SectionTitleKeyword( VIEW mSPLDef BASED ON LOD mSPLDef,
                         STRING ( 32 ) InternalEntityStructure,
                         STRING ( 32 ) InternalAttribStructure,
                         SHORT GetOrSetFlag )

   STRING ( 2048 ) szDisplayStatement

   CASE GetOrSetFlag
   OF   zDERIVED_GET:

      // Directions For Use Display Section Title embeds keywords into the Title.
      szDisplayStatement = mSPLDef.SPLD_DirectionsForUseSection.Title

      IF szDisplayStatement != ""
         GenerateKeywordTextIntoString( mSPLDef, szDisplayStatement,
                                        "SPLD_InsertTextKeywordSectionDU", "SPLD_InsertTextSectionDU", ", " )
      END

      // Store the calculated value in the object.
      StoreStringInRecord( mSPLDef, InternalEntityStructure, InternalAttribStructure, szDisplayStatement )
      RETURN 0

        // end zDERIVED_GET
   OF   zDERIVED_SET:

        // end zDERIVED_SET
   END  // case

END

/////////////////////////////////////////////////////////////////////////////
//
//  OPERATION: dDU_SectionTextKeyword
//
/////////////////////////////////////////////////////////////////////////////
DERIVED ATTRIBUTE OPERATION
dDU_SectionTextKeyword( VIEW mSPLDef BASED ON LOD mSPLDef,
                        STRING ( 32 ) InternalEntityStructure,
                        STRING ( 32 ) InternalAttribStructure,
                        SHORT GetOrSetFlag )

   STRING ( 2048 ) szDisplayStatement
   STRING ( 2048 ) szStatementText
   STRING ( 256 )  szTitle

   CASE GetOrSetFlag
   OF   zDERIVED_GET:

      // Directions For Use Display Section Text embeds keywords into the Text.
      szDisplayStatement = mSPLDef.SPLD_DirectionsForUseSection.Subtitle

      IF szDisplayStatement != ""
         GenerateKeywordTextIntoString( mSPLDef, szDisplayStatement,
                                        "SPLD_InsertTextKeywordSectionDU", "SPLD_InsertTextSectionDU", ", " )
      END

      // Store the calculated value in the object.
      StoreStringInRecord( mSPLDef, InternalEntityStructure, InternalAttribStructure, szDisplayStatement )
      RETURN 0

        // end zDERIVED_GET
   OF   zDERIVED_SET:

        // end zDERIVED_SET
   END  // case

END

/////////////////////////////////////////////////////////////////////////////
//
//  OPERATION: dDU_SectTitleOrTxtKey
//
/////////////////////////////////////////////////////////////////////////////
DERIVED ATTRIBUTE OPERATION
dDU_SectTitleOrTxtKey( VIEW mSPLDef BASED ON LOD mSPLDef,
                       STRING ( 32 ) InternalEntityStructure,
                       STRING ( 32 ) InternalAttribStructure,
                       SHORT GetOrSetFlag )

   STRING ( 2048 ) szDisplayStatement

   CASE GetOrSetFlag
   OF   zDERIVED_GET:

      // Directions For Use Display Section Title embeds keywords into the Title.
      szDisplayStatement = mSPLDef.SPLD_DirectionsForUseSection.Title
      IF szDisplayStatement = ""
         szDisplayStatement = mSPLDef.SPLD_DirectionsForUseSection.Subtitle
      END

      IF szDisplayStatement != ""
         GenerateKeywordTextIntoString( mSPLDef, szDisplayStatement,
                                        "SPLD_InsertTextKeywordSectionDU", "SPLD_InsertTextSectionDU", ", " )
      END

      // Store the calculated value in the object.
      StoreStringInRecord( mSPLDef, InternalEntityStructure, InternalAttribStructure, szDisplayStatement )
      RETURN 0

        // end zDERIVED_GET
   OF   zDERIVED_SET:

        // end zDERIVED_SET
   END  // case

END
